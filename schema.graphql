type SlackUserIdentity {
  slackTeamId: String!
  slackUserId: String!
}

type User {
  id: ID!

  """The full name e.g. Grace Hopper."""
  fullName: String!

  """A short name for use in UI e.g. Grace."""
  publicName: String!

  """The avatar URL of the user."""
  avatarUrl: String

  """The email associated with this user. Email is unique per user."""
  email: String!

  """(Legacy) Retrieve roles for a specific workspace + user."""
  roles: [Role!]!

  """The role of the user in the workspace."""
  role: Role

  """Additional legacy roles that the user has in the workspace."""
  additionalLegacyRoles: [Role!]!

  """Connected slack users to this Plain account."""
  slackIdentities: [SlackUserIdentity!]!

  """The labels associated with this user."""
  labels: [Label!]!
  status: UserStatus!
  statusChangedAt: DateTime!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: Actor
}

type UserAccount {
  id: ID!

  """The full name e.g. Grace Hopper."""
  fullName: String!

  """A short name for use in UI e.g. Grace."""
  publicName: String!

  """The email associated with this user. Email is unique per user."""
  email: String!
}

enum UserStatus {
  ONLINE
  OFFLINE
  BREAK
}

type Workspace {
  id: ID!
  name: String!
  publicName: String!
  isDemoWorkspace: Boolean!
  domainName: String @deprecated(reason: "Use domainNames instead")
  domainNames: [String!]!
  createdBy: InternalActor!
  createdAt: DateTime!
  updatedBy: InternalActor!
  updatedAt: DateTime!
  workspaceEmailSettings: WorkspaceEmailSettings!
  workspaceChatSettings: WorkspaceChatSettings!
  logo: WorkspaceFile
}

type WorkspaceInvite {
  id: ID!

  """Who sent this invite."""
  createdBy: InternalActor!

  """When the invite was created."""
  createdAt: DateTime!

  """The email that is being invited."""
  email: String!

  """The workspace they are being invited to."""
  workspace: Workspace!

  """Whether the person has accepted the invite."""
  isAccepted: Boolean!

  """The roles that the invite will assign on workspace joining."""
  roles: [Role!]!

  """Who updated this invite."""
  updatedBy: InternalActor!

  """When the invite was updated."""
  updatedAt: DateTime!

  """Whether the user would be assigned a billing rota seat upon joining."""
  usingBillingRotaSeat: Boolean!

  """
  The role that the invite will assign on workspace joining. This will replace the roles field.
  """
  role: Role
}

type Role {
  id: ID!
  name: String!
  description: String
  permissions: [String!]!
  isAssignableToCustomer: Boolean! @deprecated(reason: "Use isAssignableToThread instead")
  isAssignableToThread: Boolean!
  assignableBillingSeats: [BillingSeatType!]! @deprecated(reason: "Don't use. Will be removed soon.")
  requiresBillableSeat: Boolean! @deprecated(reason: "Don't use. Will be removed soon.")
  key: RoleKey
}

enum LabelTypeType {
  DEFAULT
  TEAM
}

type LabelType {
  id: ID!
  name: String!
  icon: String
  color: String
  type: LabelTypeType!
  description: String
  parentLabelType: LabelType

  """The position of the label type. Always relative to its parent."""
  position: String!
  isArchived: Boolean!
  archivedBy: InternalActor
  archivedAt: DateTime
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type Label {
  id: ID!
  labelType: LabelType!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""An object modelling an email address and if it's been verified."""
type EmailAddress {
  """The email address."""
  email: String!

  """
  If the email address ownership has been verified (e.g. via sending an email with a code). If the email is not verified, Plain may not email this address.
  """
  isVerified: Boolean!

  """When the email became verified in Plain."""
  verifiedAt: DateTime
}

type Company {
  id: ID!
  name: String!
  logoUrl(size: Int): String
  domainName: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  tier: Tier
  threadChannelAssociations: [ThreadChannelAssociation!]!
  contractValue: Int
  accountOwner: User
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: InternalActor
}

type CompanyEdge {
  cursor: String!
  node: Company!
}

type CompanyConnection {
  edges: [CompanyEdge!]!
  pageInfo: PageInfo!
}

type TenantEdge {
  cursor: String!
  node: Tenant!
}

type TenantConnection {
  edges: [TenantEdge!]!
  pageInfo: PageInfo!
}

enum CustomerStatus {
  IDLE @deprecated(reason: "Use ThreadStatus.DONE instead")
  ACTIVE @deprecated(reason: "Use ThreadStatus.TODO instead")
  SNOOZED @deprecated(reason: "Use ThreadStatus.SNOOZED instead")
}

type EmailCustomerIdentity {
  email: String!
}

type DiscordCustomerIdentity {
  discordUserId: String!
}

type SlackCustomerIdentity {
  slackUserId: String!
}

union CustomerIdentity = EmailCustomerIdentity | DiscordCustomerIdentity | SlackCustomerIdentity

"""
The core customer entity. A customer only exists (ideally) once.
Uniqueness is guaranteed on both of these fields:
1. `externalId` if provided
2. `email`
"""
type Customer {
  """Uniquely identifies a customer in Plain."""
  id: ID!

  """Your system's ID for this customer."""
  externalId: ID

  """The full name of the customer."""
  fullName: String!

  """An optional short name of the customer, typically their first name."""
  shortName: String

  """The customer's email address."""
  email: EmailAddress!

  """The avatar URL of the customer."""
  avatarUrl: String

  """The user the customer is assigned to."""
  assignedToUser: UserActor

  """When the customer was assigned to a user."""
  assignedAt: DateTime

  """A subquery to fetch the customer's group memberships."""
  customerGroupMemberships(filters: CustomerGroupMembershipsFilter, first: Int, after: String, last: Int, before: String): CustomerGroupMembershipConnection!

  """A subquery to fetch the customer's tenants."""
  tenantMemberships(first: Int, after: String, last: Int, before: String): CustomerTenantMembershipConnection!

  """The company the customer belongs to."""
  company: Company
  isAnonymous: Boolean!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
  markedAsSpamAt: DateTime
  markedAsSpamBy: InternalActor
  identities: [CustomerIdentity!]!
  status: CustomerStatus @deprecated(reason: "Use Thread.status instead")
  statusChangedAt: DateTime @deprecated(reason: "Use Thread.statusChangedAt instead")
  lastIdleAt: DateTime @deprecated(reason: "Use Thread.statusChangedAt instead")
}

type CustomerGroup {
  id: ID!
  name: String!
  key: String!
  color: String!
  externalId: String
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerGroupMembership {
  customerId: ID!
  customerGroup: CustomerGroup!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerGroupEdge {
  cursor: String!
  node: CustomerGroup!
}

type CustomerGroupConnection {
  edges: [CustomerGroupEdge!]!
  pageInfo: PageInfo!
}

type CustomerGroupMembershipEdge {
  cursor: String!
  node: CustomerGroupMembership!
}

type CustomerGroupMembershipConnection {
  edges: [CustomerGroupMembershipEdge!]!
  pageInfo: PageInfo!
}

type CustomerTenantMembership {
  tenant: Tenant!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerTenantMembershipEdge {
  cursor: String!
  node: CustomerTenantMembership!
}

type CustomerTenantMembershipConnection {
  edges: [CustomerTenantMembershipEdge!]!
  pageInfo: PageInfo!
}

enum ThreadFieldSchemaType {
  STRING
  BOOL
  ENUM
}

type DependsOnThreadFieldType {
  threadFieldSchemaId: ID!
  threadFieldSchemaValue: String!
}

type DependsOnLabelType {
  labelTypeId: ID!
}

type ThreadFieldSchema {
  id: ID!
  label: String!
  key: String!
  description: String!
  order: Int!
  type: ThreadFieldSchemaType!
  enumValues: [String!]!
  defaultStringValue: String
  defaultBooleanValue: Boolean
  isRequired: Boolean!
  isAiAutoFillEnabled: Boolean!
  dependsOnThreadField: DependsOnThreadFieldType
  dependsOnLabels: [DependsOnLabelType!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ThreadField {
  id: ID!
  threadId: ID!
  key: String!
  type: ThreadFieldSchemaType!
  isAiGenerated: Boolean!
  stringValue: String
  booleanValue: Boolean
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ThreadDiscussion {
  id: ID!
  threadId: ID!
  title: String!
  slackTeamId: String!
  slackChannelId: String!
  slackChannelName: String!
  slackMessageLink: String!
  messages(first: Int, after: String, last: Int, before: String): ThreadDiscussionMessageConnection!
  resolvedAt: DateTime
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ThreadDiscussionMessageConnection {
  edges: [ThreadDiscussionMessageEdge!]!
  pageInfo: PageInfo!
}

type ThreadDiscussionMessageEdge {
  node: ThreadDiscussionMessage!
  cursor: String!
}

type ThreadDiscussionMessageReaction {
  name: String!
  actors: [Actor!]!
  imageUrl: String
}

type ThreadDiscussionMessage {
  id: ID!
  threadDiscussionId: ID!
  text: String!
  slackMessageLink: String!
  attachments: [Attachment!]!
  lastEditedOnSlackAt: DateTime
  deletedOnSlackAt: DateTime
  reactions: [ThreadDiscussionMessageReaction!]!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type WorkflowRule {
  id: ID!
  name: String!

  """JSON-encoded payload of the rule definition."""
  payload: String!
  publishedAt: DateTime
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkflowRuleEdge {
  cursor: String!
  node: WorkflowRule!
}

type WorkflowRuleConnection {
  edges: [WorkflowRuleEdge!]!
  pageInfo: PageInfo!
}

type ChatAppSecret {
  chatAppId: ID!
  secret: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatAppHiddenSecret {
  chatAppId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatApp {
  id: ID!
  name: String!
  logo: WorkspaceFile
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ChatAppEdge {
  cursor: String!
  node: ChatApp!
}

type ChatAppConnection {
  edges: [ChatAppEdge!]!
  pageInfo: PageInfo!
}

type Note {
  id: ID!
  text: String!
  markdown: String
  customer: Customer!
  attachments: [Attachment!]!
  isDeleted: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  deletedAt: DateTime
  deletedBy: InternalActor
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SavedThreadsViewSort {
  field: ThreadsSortField
  direction: SortDirection
}

type SavedThreadsViewFilterThreadField {
  key: String!
  stringValue: String
  booleanValue: Boolean
}

type ThreadsDisplayOptions {
  hasStatus: Boolean!
  hasCustomer: Boolean!
  hasCompany: Boolean!
  hasPreviewText: Boolean!
  hasTier: Boolean!
  hasCustomerGroups: Boolean!
  hasLabels: Boolean!
  hasLinearIssues: Boolean! @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasJiraIssues: Boolean! @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLinkedThreads: Boolean!
  hasServiceLevelAgreements: Boolean!
  hasChannels: Boolean!
  hasLastUpdated: Boolean!
  hasAssignees: Boolean!
  hasIssueTrackerIssues: Boolean!
}

enum ThreadsLayout {
  TABLE
  BOARD
}

enum ThreadsGroupBy {
  NONE
  PRIORITY
  STATUS
  COMPANY
  LABEL
  TIER
  CHANNEL
  ASSIGNEE
  CUSTOMER_GROUP
  TENANT
}

type SavedThreadsViewFilter {
  statuses: [ThreadStatus!]!
  statusDetails: [StatusDetailType!]!
  priorities: [Int!]!
  assignedToUser: [ID!]!
  participants: [ID!]!
  customerGroups: [ID!]!
  companies: [ID!]!
  tenants: [ID!]!
  tiers: [ID!]!
  labelTypeIds: [ID!]!
  messageSource: [MessageSource!]!
  supportEmailAddresses: [String!]!
  slaTypes: [String!]!
  slaStatuses: [String!]!
  threadFields: [SavedThreadsViewFilterThreadField!]!
  threadLinkGroupIds: [ID!]!
  sort: SavedThreadsViewSort!
  displayOptions: ThreadsDisplayOptions!
  groupBy: ThreadsGroupBy!
  layout: ThreadsLayout!
}

type SavedThreadsView {
  id: ID!
  name: String!
  icon: String!
  color: String!
  threadsFilter: SavedThreadsViewFilter!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SavedThreadsViewConnection {
  pageInfo: PageInfo!
  edges: [SavedThreadsViewEdge!]!
}

type SavedThreadsViewEdge {
  cursor: String!
  node: SavedThreadsView!
}

type FavoritePage {
  id: ID!
  key: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type FavoritePageConnection {
  pageInfo: PageInfo!
  edges: [FavoritePageEdge!]!
}

type FavoritePageEdge {
  cursor: String!
  node: FavoritePage!
}

type Snippet {
  id: ID!
  name: String!
  text: String!
  markdown: String
  path: String
  isDeleted: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  deletedAt: DateTime
  deletedBy: InternalActor
}

type EmailSignature {
  text: String!
  markdown: String
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type Chat {
  id: ID!
  text: String
  customerReadAt: DateTime
  attachments: [Attachment!]!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type PageInfo {
  hasPreviousPage: Boolean!
  hasNextPage: Boolean!
  startCursor: String
  endCursor: String
}

type DateTime {
  unixTimestamp: String!
  iso8601: String!
}

type Time {
  iso8601: String!
}

enum SortDirection {
  ASC
  DESC
}

type WorkspaceEdge {
  cursor: String!
  node: Workspace!
}

type WorkspaceConnection {
  edges: [WorkspaceEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceInviteEdge {
  cursor: String!
  node: WorkspaceInvite!
}

type WorkspaceInviteConnection {
  edges: [WorkspaceInviteEdge!]!
  pageInfo: PageInfo!
}

input UsersFilter {
  isAssignableToCustomer: Boolean @deprecated(reason: "Use isAssignableToThread instead")
  isAssignableToThread: Boolean
}

type UserEdge {
  cursor: String!
  node: User!
}

type UserConnection {
  edges: [UserEdge!]!
  pageInfo: PageInfo!
}

type RoleEdge {
  cursor: String!
  node: Role!
}

type RoleConnection {
  edges: [RoleEdge!]!
  pageInfo: PageInfo!
}

type LabelTypeEdge {
  cursor: String!
  node: LabelType!
}

type LabelTypeConnection {
  edges: [LabelTypeEdge!]!
  pageInfo: PageInfo!
}

input LabelTypeFilter {
  isArchived: Boolean
}

type ThreadFieldSchemaEdge {
  cursor: String!
  node: ThreadFieldSchema!
}

type ThreadFieldSchemaConnection {
  edges: [ThreadFieldSchemaEdge!]!
  pageInfo: PageInfo!
}

input CustomersFilter {
  isMarkedAsSpam: Boolean

  """
  Filters customers to those with at least one of the given customer group IDs.
  Customers with no groups will not be included.
  Can be combined with other group filters.
  """
  customerGroupIds: [ID!]

  """
  Filters customers to those with at least one of the given customer group keys.
  Customers with no groups will not be included.
  Can be combined with other group filters.
  """
  customerGroupKeys: [String!]

  """
  Filters customers to those belonging to the given companies.
  Customers who dont belong to any of the given companies will not be included.
  Can be combined with other company filters.
  """
  companyIdentifiers: [CompanyIdentifierInput!]

  """
  Filters customers to those belonging to the given tenants.
  Customers who dont belong to any of the given tenants will not be included.
  Can be combined with other company filters.
  """
  tenantIdentifiers: [TenantIdentifierInput!]
}

enum CustomersSortField {
  FULL_NAME
}

input CustomersSort {
  field: CustomersSortField!
  direction: SortDirection!
}

type CustomerEdge {
  cursor: String!
  node: Customer!
}

type CustomerConnection {
  edges: [CustomerEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type SnippetEdge {
  cursor: String!
  node: Snippet!
}

type SnippetConnection {
  edges: [SnippetEdge!]!
  pageInfo: PageInfo!
}

type UserActor {
  userId: ID!
  user: User!
}

type CustomerActor {
  customerId: ID!
  customer: Customer!
}

type DeletedCustomerActor {
  customerId: ID!
}

type SystemActor {
  systemId: ID!
}

type System {
  id: ID!
}

type MachineUserActor {
  machineUserId: ID!
  machineUser: MachineUser!
}

type NoteEntry {
  noteId: ID!
  text: String!
  markdown: String
  attachments: [Attachment!]!
}

type ChatEntry {
  chatId: ID!
  text: String
  customerReadAt: DateTime
  attachments: [Attachment!]!
}

interface TimelineEventEntry {
  timelineEventId: ID!
  title: String!
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
}

type ThreadEventEntry implements TimelineEventEntry {
  timelineEventId: ID!
  title: String!
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
}

type CustomerEventEntry implements TimelineEventEntry {
  timelineEventId: ID!
  title: String!
  components: [EventComponent!]!
  customerId: ID!
  externalId: ID
}

type SlackReaction {
  name: String!
  actors: [Actor!]!
  imageUrl: String
}

type SlackMessageEntry {
  slackMessageLink: String!
  slackWebMessageLink: String!
  text: String!
  customerId: ID!
  relatedThread: SlackMessageEntryRelatedThread
  attachments: [Attachment!]!
  lastEditedOnSlackAt: DateTime
  deletedOnSlackAt: DateTime
  reactions: [SlackReaction!]!
}

type SlackMessageEntryRelatedThread {
  threadId: ID!
}

type SlackReplyEntry {
  slackMessageLink: String!
  slackWebMessageLink: String!
  customerId: ID!
  text: String!
  attachments: [Attachment!]!
  lastEditedOnSlackAt: DateTime
  deletedOnSlackAt: DateTime
  reactions: [SlackReaction!]!
}

type MSTeamsMessage {
  id: ID!
  threadId: ID
  msTeamsTenantId: ID
  msTeamsConversationId: ID
  msTeamsMessageId: ID
  msTeamsTeamId: ID
  text: String!
  html: String!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
  attachments: [Attachment!]!
  lastEditedOnMsTeamsAt: DateTime
  deletedOnMsTeamsAt: DateTime
}

type MSTeamsMessageEntry {
  text: String!
  customerId: ID!
  msTeamsMessageId: ID!
  attachments: [Attachment!]!
  lastEditedOnMsTeamsAt: DateTime
  deletedOnMsTeamsAt: DateTime
}

type DiscordMessageEntry {
  customerId: ID!
  discordMessageId: ID!
  markdownContent: String
  attachments: [Attachment!]!
  lastEditedOnDiscordAt: DateTime
  deletedOnDiscordAt: DateTime
  discordMessageLink: String!
}

type ThreadDiscussionEntry {
  customerId: ID!
  threadDiscussionId: ID!
  slackChannelName: String!
  slackMessageLink: String!
}

type ThreadDiscussionResolvedEntry {
  customerId: ID!
  threadDiscussionId: ID!
  slackChannelName: String!
  slackMessageLink: String!
  resolvedAt: DateTime!
}

type FileSize {
  bytes: Int!
  kiloBytes: Float!
  megaBytes: Float!
}

type Attachment {
  id: ID!
  fileName: String!
  fileSize: FileSize!
  fileExtension: String
  fileMimeType: String!
  type: AttachmentType!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type DiscordMessage {
  discordMessageId: ID!
  markdownContent: String
  attachments: [Attachment!]!
  lastEditedOnDiscordAt: DateTime
  deletedOnDiscordAt: DateTime
  discordMessageLink: String!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type CustomerEmailActor {
  customerId: ID!
  customer: Customer!
}

type DeletedCustomerEmailActor {
  customerId: ID!
}

type UserEmailActor {
  userId: ID!
  user: User!
}

type SupportEmailAddressEmailActor {
  supportEmailAddress: String!
}

union EmailActor = CustomerEmailActor | DeletedCustomerEmailActor | UserEmailActor | SupportEmailAddressEmailActor

type EmailParticipant {
  name: String
  email: String!
  emailActor: EmailActor
}

enum EmailAuthenticity {
  PASS
  FAIL
  UNKNOWN
}

type EmailBounce {
  bouncedAt: DateTime!
  recipient: EmailParticipant!
  isSendRetriable: Boolean!
}

enum EmailSendStatus {
  """The email is being sent."""
  PENDING

  """The email was sent successfully to all recipients."""
  SENT

  """
  Some (or all) of the recipients bounced the email, meaning they did not recieve it. Check 'bounces' for more details on which recipients bounced.
  """
  BOUNCED

  """
  The email failed to send. This will happen if the main recipient (To) bounced the email, or if there was an unexpected error sending the email.
  """
  FAILED
}

type EmailEntry {
  emailId: ID!
  to: EmailParticipant!
  from: EmailParticipant!
  additionalRecipients: [EmailParticipant!]!
  hiddenRecipients: [EmailParticipant!]!
  subject: String

  """The most recent email's text content."""
  textContent: String

  """
  Boolean indicating whether there is more text content available that can be resolved via the `fullTextContent` field.
  """
  hasMoreTextContent: Boolean!

  """The full email's text content, including all replies."""
  fullTextContent: String

  """The most recent email's markdown content."""
  markdownContent: String

  """
  Boolean indicating whether there is more markdown content available that can be resolved via the `fullMarkdownContent` field.
  """
  hasMoreMarkdownContent: Boolean!

  """The full email's markdown content, including all replies."""
  fullMarkdownContent: String
  authenticity: EmailAuthenticity!

  """
  When the email was sent. Only set for outbound emails and will be null until the email is sent.
  """
  sentAt: DateTime

  """
  Informs whether the email was sent successfully, bounced or failed. If the email is still being sent, the status will be 'PENDING'. Only set for outbound emails.
  """
  sendStatus: EmailSendStatus

  """When the email was received by Plain."""
  receivedAt: DateTime

  """All the attachments included in this email."""
  attachments: [Attachment!]!

  """
  Whether this email entry is the start of a new thread in Plain. Can be used to show the full email content.
  """
  isStartOfThread: Boolean!

  """
  If any of the recipients bounces the email, this will contain the list of bounces.
  """
  bounces: [EmailBounce!]!
}

enum ComponentTextSize {
  S
  M
  L
}

enum ComponentTextColor {
  NORMAL
  MUTED
  SUCCESS
  WARNING
  ERROR
}

enum ComponentPlainTextSize {
  S
  M
  L
}

enum ComponentPlainTextColor {
  NORMAL
  MUTED
  SUCCESS
  WARNING
  ERROR
}

enum ComponentBadgeColor {
  GREY
  GREEN
  YELLOW
  RED
  BLUE
}

type ComponentText {
  textSize: ComponentTextSize
  textColor: ComponentTextColor
  text: String!
  color: ComponentTextColor @deprecated(reason: "Use textColor instead, which has the same type")
  size: ComponentTextSize @deprecated(reason: "Use textSize instead, which has the same type")
}

type ComponentPlainText {
  plainTextSize: ComponentPlainTextSize
  plainTextColor: ComponentPlainTextColor
  plainText: String!
}

enum ComponentSpacerSize {
  XS
  S
  M
  L
  XL
}

type ComponentSpacer {
  spacerSize: ComponentSpacerSize!
  size: ComponentSpacerSize! @deprecated(reason: "Use spacerSize instead, which has the same type")
}

enum ComponentDividerSpacingSize {
  XS
  S
  M
  L
  XL
}

type ComponentDivider {
  dividerSpacingSize: ComponentDividerSpacingSize
  spacingSize: ComponentDividerSpacingSize @deprecated(reason: "use dividerSpacingSize instead")
}

type ComponentLinkButton {
  linkButtonUrl: String!
  linkButtonLabel: String!
  url: String! @deprecated(reason: "use linkButtonUrl instead")
  label: String! @deprecated(reason: "use linkButtonLabel instead")
}

type ComponentCopyButton {
  copyButtonValue: String!
  copyButtonTooltipLabel: String
}

type ComponentBadge {
  badgeLabel: String!
  badgeColor: ComponentBadgeColor
}

type ComponentRow {
  rowMainContent: [ComponentRowContent!]!
  rowAsideContent: [ComponentRowContent!]!
}

type ComponentContainer {
  containerContent: [ComponentContainerContent!]!
}

union ComponentContainerContent = ComponentText | ComponentPlainText | ComponentSpacer | ComponentDivider | ComponentLinkButton | ComponentBadge | ComponentCopyButton | ComponentRow

union ComponentRowContent = ComponentText | ComponentPlainText | ComponentSpacer | ComponentDivider | ComponentLinkButton | ComponentBadge | ComponentCopyButton

union CustomTimelineEntryComponent = ComponentText | ComponentPlainText | ComponentSpacer | ComponentDivider | ComponentLinkButton | ComponentRow | ComponentContainer | ComponentBadge | ComponentCopyButton

union EventComponent = ComponentText | ComponentPlainText | ComponentSpacer | ComponentDivider | ComponentLinkButton | ComponentRow | ComponentBadge | ComponentCopyButton

union CustomerCardComponent = ComponentText | ComponentPlainText | ComponentSpacer | ComponentDivider | ComponentLinkButton | ComponentRow | ComponentContainer | ComponentBadge | ComponentCopyButton

type CustomEntry {
  externalId: ID
  title: String!
  type: String
  components: [CustomTimelineEntryComponent!]!
  attachments: [Attachment!]!
}

type ThreadAssignmentTransitionedEntry {
  previousAssignee: ThreadAssignee
  nextAssignee: ThreadAssignee
}

type ThreadAdditionalAssigneesTransitionedEntry {
  previousAssignees: [ThreadAssignee!]!
  nextAssignees: [ThreadAssignee!]!
}

type ThreadStatusTransitionedEntry {
  previousStatus: ThreadStatus!
  previousStatusDetail: ThreadStatusDetail
  nextStatus: ThreadStatus!
  nextStatusDetail: ThreadStatusDetail
}

type ThreadPriorityChangedEntry {
  previousPriority: Int!
  nextPriority: Int!
}

type ThreadLabelsChangedEntry {
  previousLabels: [Label!]!
  nextLabels: [Label!]!
}

type ServiceLevelAgreementStatusTransitionedEntry {
  previousStatus: ServiceLevelAgreementStatus!
  nextStatus: ServiceLevelAgreementStatus!
  serviceLevelAgreement: ServiceLevelAgreement
}

union Actor = UserActor | CustomerActor | DeletedCustomerActor | SystemActor | MachineUserActor

union InternalActor = UserActor | SystemActor | MachineUserActor

"""A union of all possible entries that can appear in a timeline."""
union Entry = NoteEntry | ChatEntry | EmailEntry | CustomEntry | LinearIssueThreadLinkStateTransitionedEntry | ThreadAssignmentTransitionedEntry | ThreadAdditionalAssigneesTransitionedEntry | ThreadStatusTransitionedEntry | ThreadPriorityChangedEntry | ThreadEventEntry | CustomerEventEntry | SlackMessageEntry | SlackReplyEntry | ThreadLabelsChangedEntry | ThreadDiscussionEntry | ThreadDiscussionResolvedEntry | ServiceLevelAgreementStatusTransitionedEntry | MSTeamsMessageEntry | DiscordMessageEntry | ThreadLinkUpdatedEntry | HelpCenterAiConversationMessageEntry

type HelpCenterAiConversationMessageEntry {
  helpCenterId: ID!
  helpCenterAiConversationId: ID!
  messageId: ID!
  markdown: String!
}

type LinearIssueThreadLinkStateTransitionedEntry {
  linearIssueId: ID!

  """
  Refers to the id of the WorkflowState object in Linear. This can be used to fetch the WorkflowState from the Linear API.
  """
  previousLinearStateId: ID!

  """
  Refers to the id of the WorkflowState object in Linear. This can be used to fetch the WorkflowState from the Linear API.
  """
  nextLinearStateId: ID!
}

type ThreadLinkUpdatedEntry {
  threadLink: ThreadLink!
  previousThreadLink: ThreadLink!
}

type TimelineEntry {
  id: ID!
  customerId: ID!
  threadId: ID!
  timestamp: DateTime!
  entry: Entry!
  actor: Actor!
  llmText: String
}

type CustomerEvent {
  """The ID of the event."""
  id: ID!

  """The customer that this event belongs to."""
  customerId: ID!

  """The title of the event."""
  title: String!

  """The list of components of the event."""
  components: [EventComponent!]!

  """The datetime when this event was created."""
  createdAt: DateTime!

  """The actor who created this event."""
  createdBy: Actor!

  """The datetime when this event was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this event."""
  updatedBy: Actor!
}

type ThreadEvent {
  """The ID of the event."""
  id: ID!

  """The customer that this event belongs to."""
  customerId: ID!

  """The thread that this event belongs to."""
  threadId: ID!

  """The title of the event."""
  title: String!

  """The list of components of the event."""
  components: [EventComponent!]!

  """The datetime when this event was created."""
  createdAt: DateTime!

  """The actor who created this event."""
  createdBy: Actor!

  """The datetime when this event was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this event."""
  updatedBy: Actor!
}

type TimelineEntryEdge {
  cursor: String!
  node: TimelineEntry!
}

type TimelineEntryConnection {
  edges: [TimelineEntryEdge!]!
  pageInfo: PageInfo!
}

type MachineUser {
  id: ID!
  fullName: String!
  publicName: String!
  description: String

  """
  The type of machine user. Defaults to API_USER if not specified during creation.
  """
  type: MachineUserType!
  avatar: WorkspaceFile
  apiKey(apiKeyId: ID!): ApiKey
  apiKeys(first: Int, after: String, last: Int, before: String): ApiKeyConnection!
  createdBy: InternalActor!
  createdAt: DateTime!
  updatedBy: InternalActor!
  updatedAt: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: Actor
}

type MachineUserEdge {
  cursor: String!
  node: MachineUser!
}

type MachineUserConnection {
  edges: [MachineUserEdge!]!
  pageInfo: PageInfo!
}

type ApiKey {
  id: ID!
  description: String
  permissions: [String!]!
  createdBy: InternalActor!
  createdAt: DateTime!
  updatedBy: InternalActor!
  updatedAt: DateTime!
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: Actor
}

type ApiKeyEdge {
  cursor: String!
  node: ApiKey!
}

type ApiKeyConnection {
  edges: [ApiKeyEdge!]!
  pageInfo: PageInfo!
}

type Permissions {
  permissions: [String!]!
}

type WorkspaceMSTeamsInstallationInfo {
  installationUrl: String!
}

type UserMSTeamsInstallationInfo {
  installationUrl: String
}

type UserMSTeamsIntegration {
  id: ID!
  msTeamsTenantId: ID!
  isReinstallRequired: Boolean!
  msTeamsPreferredUsername: String
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserSlackInstallationInfo {
  installationUrl: String!
}

type WorkspaceSlackInstallationInfo {
  installationUrl: String!
}

type WorkspaceSlackChannelInstallationInfo {
  installationUrl: String!
}

type UserAuthSlackInstallationInfo {
  installationUrl: String!
}

type UserSlackIntegration {
  integrationId: ID!
  slackTeamName: String!
  isReinstallRequired: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserAuthSlackIntegration {
  integrationId: ID!
  slackTeamId: String!
  slackTeamName: String!
  isReinstallRequired: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceSlackIntegration {
  integrationId: ID!
  slackChannelName: String!
  slackTeamName: String!
  slackTeamImageUrl68px: String
  isReinstallRequired: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceSlackIntegrationEdge {
  cursor: String!
  node: WorkspaceSlackIntegration!
}

type WorkspaceSlackIntegrationConnection {
  edges: [WorkspaceSlackIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceSlackChannelIntegrationEdge {
  cursor: String!
  node: WorkspaceSlackChannelIntegration!
}

type WorkspaceSlackChannelIntegrationConnection {
  edges: [WorkspaceSlackChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

type WorkspaceSlackChannelIntegration {
  integrationId: ID!
  slackTeamId: String!
  slackTeamName: String!
  slackTeamImageUrl68px: String
  isReinstallRequired: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceDiscordChannelIntegration {
  id: ID!
  discordGuildId: String!
  discordGuildName: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceDiscordChannelInstallationInfo {
  installationUrl: String!
}

type WorkspaceDiscordIntegration {
  integrationId: ID!
  name: String!
  webhookUrl: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceDiscordChannelIntegrationEdge {
  cursor: String!
  node: WorkspaceDiscordChannelIntegration!
}

type WorkspaceDiscordChannelIntegrationConnection {
  edges: [WorkspaceDiscordChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

type UserAuthDiscordChannelInstallationInfo {
  installationUrl: String!
}

type WorkspaceDiscordIntegrationEdge {
  cursor: String!
  node: WorkspaceDiscordIntegration!
}

type WorkspaceDiscordIntegrationConnection {
  edges: [WorkspaceDiscordIntegrationEdge!]!
  pageInfo: PageInfo!
}

type UserLinearInstallationInfo {
  installationUrl: String!
}

type LinearIntegrationToken {
  token: String!
}

type JiraIntegrationToken {
  token: String!
  createdAt: DateTime!
}

type UserLinearIntegration {
  integrationId: ID!
  linearOrganisationName: String!
  linearOrganisationId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

"""An API header that will be sent to the configured API URL."""
type CustomerCardConfigApiHeader {
  """
  The name of the header, trimmed and treated case insensitively for deduplication purposes (min length: 1, max length: 100). Not all header names are allowed.
  """
  name: String!

  """
  The value of the header, treated case sensitively for deduplication purposes (min length: 1, max length: 500).
  """
  value: String!
}

"""
The configuration of a customer card that defines four important things:

- The title of the card
- The key of the card, which will be used in the request payload to the API URL
- The order in which the cards should appear
- Which API the card should be loaded from (and the required authentication headers)

Configs that have the same API URL and API Headers will be loaded in batch. API header names are treated case insensitively.

A maximum of 25 customer cards can be configured.
"""
type CustomerCardConfig {
  """The ID of the customer card config."""
  id: ID!

  """
  The order in which this customer card config should be shown.
  
  Duplicate order numbers are allowed, in case the order is the same they will be sorted based on `id`. The minimum is 0 and the maximum is 100000.
  """
  order: Int!

  """The title of the card (max length: 500 characters)."""
  title: String!

  """
  The key of the card (must be unique in a workspace, max length: 500 characters, must match regex: `[a-zA-Z0-9_-]+`).
  """
  key: String!

  """
  The default time the card should be cached for if no TTL is provided in the card response. (minimum: 15 seconds, maximum: 1 year or  31,536,000 seconds).
  """
  defaultTimeToLiveSeconds: Int!

  """
  The URL from which this card should be loaded (must start with `https://` and be a valid URL, max length: 600 characters). Requires the `customerCardConfigApiDetails:read` permission.
  """
  apiUrl: String!

  """
  An array of headers name-value pairs (maximum length of array: 20). Requires the `customerCardConfigApiDetails:read` permission.
  """
  apiHeaders: [CustomerCardConfigApiHeader!]!

  """
  Indicates if the customer card is enabled or not. Disabled customer card configs are not loaded or displayed for customers.
  """
  isEnabled: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SettingScope {
  id: ID
  scopeType: SettingScopeType!
}

"""A boolean setting"""
type BooleanSetting {
  """The setting code."""
  code: String!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  booleanValue: Boolean!

  """The scope of the setting."""
  scope: SettingScope!
}

"""A string setting"""
type StringSetting {
  """The setting code."""
  code: String!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  stringValue: String!

  """The scope of the setting."""
  scope: SettingScope!
}

"""A number setting"""
type NumberSetting {
  """The setting code."""
  code: String!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  numberValue: Int!

  """The scope of the setting."""
  scope: SettingScope!
}

"""A string array setting"""
type StringArraySetting {
  """The setting code."""
  code: String!

  """
  The value of the setting. This is named uniquely (instead of just `value`) so that the union has unique fields.
  """
  stringArrayValue: [String!]!

  """The scope of the setting."""
  scope: SettingScope!
}

"""A union of different types of settings."""
union Setting = BooleanSetting | StringSetting | NumberSetting | StringArraySetting

"""An enum to describe the type of scope the setting is for."""
enum SettingScopeType {
  """
  Scope for any user level settings
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER

  """
  Scope for any chat application settings
  An `id` is mandatory and should be a chat application id (`liveChatApp_123`)
  """
  CHAT

  """
  Scope for the authenticated user's email notification settings.
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER_EMAIL_NOTIFICATIONS

  """
  Scope for the authenticated user's slack notification settings.
  An `id` is not needed as it will implicitly be the authenticated user's id.
  """
  USER_SLACK_NOTIFICATIONS

  """
  Scope for slack support channel settings.
  An `id` is mandatory and should be a workspace slack channel integration id (`wsSlackInt_123`)
  """
  WORKSPACE_SLACK_CHANNEL

  """
  Scope for slack notifications configured for the whole workspace.
  An `id` is mandatory and should be a workspace slack integration id (`wsSlackInt_123`)
  """
  WORKSPACE_SLACK_NOTIFICATIONS

  """
  Scope for discord notifications configured for the whole workspace.
  An `id` is mandatory and should be a workspace discord integration id (`wsDiscordInt_123`)
  """
  WORKSPACE_DISCORD_NOTIFICATIONS

  """
  Scope for workspace level settings for the whole workspace.
  An `id` is not needed as it will implicitly be the current workspace id.
  """
  WORKSPACE
}

"""
The different ways in which a string is matched.
Exactly one of these must be provided in a single search expression.
"""
input StringSearchExpression {
  """Case-insensitive match values containing the provided string."""
  caseInsensitiveContains: String
}

"""
The customer attributes available for search, each of them mapped to a search expression.
Exactly one of them must be provided in a single search condition.
"""
input CustomerSearchCondition {
  """Search expression on the customer's full name."""
  fullName: StringSearchExpression

  """Search expression on the customer's short name."""
  shortName: StringSearchExpression

  """Search expression on the customer's email address."""
  email: StringSearchExpression

  """Search expression on the customer's external id."""
  externalId: StringSearchExpression

  """
  Search expression on specific timeline entries' text (email, chat) sent or received by the customer.
  Common English stop-words will be removed from the text to search.
  """
  timelineEntryText: StringSearchExpression
}

"""
A query to search for customers. Search queries are combinations of search conditions, as defined
below. At least one search condition must be provided.
"""
input CustomersSearchQuery {
  """
  An array of search conditions that will be combined using a 'logical OR' to search for customers.
  """
  or: [CustomerSearchCondition!]
}

type CustomerSearchEdge {
  cursor: String!
  node: Customer!
}

type CustomerSearchConnection {
  edges: [CustomerSearchEdge!]!
  pageInfo: PageInfo!
}

"""
A shared interface for all common properties customer card instances can have.
A customer can only have one customer card instance for each customer card config at any point in time.

Has 3 implementations:
- `CustomerCardInstanceLoading`
- `CustomerCardInstanceLoaded`
- `CustomerCardInstanceError`
"""
interface CustomerCardInstance {
  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """The customer the instance is for."""
  customerId: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""
A loading customer card. The createdAt timestamp indicates when the load was started.
Will be updated to be a CustomerCardInstanceLoaded or CustomerCardInstanceError.
"""
type CustomerCardInstanceLoading implements CustomerCardInstance {
  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """The customer the instance is for."""
  customerId: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""A loaded customer card."""
type CustomerCardInstanceLoaded implements CustomerCardInstance {
  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """The customer the instance is for."""
  customerId: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """
  The list of components of the customer card. If this is null it means the customer card was returned on the API, but the components array was empty.
  """
  components: [CustomerCardComponent!]

  """When the customer card was received from the API."""
  loadedAt: DateTime!
  expiresAt: DateTime!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

"""The configured API URL didn't return a requested card key."""
type CustomerCardInstanceMissingCardErrorDetail {
  message: String!
  cardKey: String!
}

"""An invalid response body was returned from the configured API URL."""
type CustomerCardInstanceResponseBodyErrorDetail {
  message: String!
  responseBody: String!
}

"""A non-200 status code was returned from the configured API URL."""
type CustomerCardInstanceStatusCodeErrorDetail {
  message: String!
  statusCode: Int!
  responseBody: String!
}

"""Plain failed to make the request to the configured API URL."""
type CustomerCardInstanceRequestErrorDetail {
  message: String!
  errorCode: String!
}

"""
An unknown error occurred. If this error is persistent, please contact our support.
"""
type CustomerCardInstanceUnknownErrorDetail {
  message: String!
}

"""The card failed to load within the timeout."""
type CustomerCardInstanceTimeoutErrorDetail {
  message: String!
  timeoutSeconds: Int!
}

"""Details for the reasons why the customer card failed to load."""
union CustomerCardInstanceErrorDetail = CustomerCardInstanceMissingCardErrorDetail | CustomerCardInstanceResponseBodyErrorDetail | CustomerCardInstanceStatusCodeErrorDetail | CustomerCardInstanceRequestErrorDetail | CustomerCardInstanceUnknownErrorDetail | CustomerCardInstanceTimeoutErrorDetail

type CustomerCardInstanceError implements CustomerCardInstance {
  """
  The ID of the customer card instance. A new ID is generated for each load.
  """
  id: ID!

  """The customer the instance is for."""
  customerId: ID!

  """
  The thread the instance is for. Null if this card is not loaded in a thread context.
  """
  threadId: ID

  """The customer card config this instance is for."""
  customerCardConfig: CustomerCardConfig!

  """The details of the customer card load error."""
  errorDetail: CustomerCardInstanceErrorDetail!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type Query {
  myUserAccount: UserAccount
  myUser: User
  myMachineUser: MachineUser
  myWorkspace: Workspace
  myPermissions: Permissions!
  myWorkspaces(first: Int, after: String, last: Int, before: String): WorkspaceConnection!
  myWorkspaceInvites(first: Int, after: String, last: Int, before: String): WorkspaceInviteConnection!
  mySlackIntegration: UserSlackIntegration
  mySlackInstallationInfo(redirectUrl: String!): UserSlackInstallationInfo!
  myLinearIntegration: UserLinearIntegration
  myLinearInstallationInfo(redirectUrl: String!): UserLinearInstallationInfo!
  myLinearIntegrationToken: LinearIntegrationToken
  myJiraIntegrationToken: JiraIntegrationToken
  myEmailSignature: EmailSignature
  myFavoritePages(first: Int, after: String, last: Int, before: String): FavoritePageConnection!
  billingPlans(first: Int, after: String, last: Int, before: String): BillingPlanConnection!
  myBillingSubscription: BillingSubscription
  myBillingRota: BillingRota
  myPaymentMethod: PaymentMethod
  labelTypes(filters: LabelTypeFilter, first: Int, after: String, last: Int, before: String): LabelTypeConnection!
  labelType(labelTypeId: ID!): LabelType
  roles(first: Int, after: String, last: Int, before: String): RoleConnection!
  timelineEntries(customerId: ID!, first: Int, after: String, last: Int, before: String): TimelineEntryConnection!
  timelineEntry(customerId: ID!, timelineEntryId: ID!): TimelineEntry
  workspace(workspaceId: ID!): Workspace
  user(userId: ID!): User

  """
  Returns a user by email or null if the user is not found.
  
  Deleted users are also returned, see isDeleted, deletedAt and deletedBy fields on the User type.
  """
  userByEmail(email: String!): User
  users(filters: UsersFilter, first: Int, after: String, last: Int, before: String): UserConnection!
  workspaceInvites(first: Int, after: String, last: Int, before: String): WorkspaceInviteConnection!
  customer(customerId: ID!): Customer
  customers(filters: CustomersFilter, sortBy: CustomersSort, first: Int, after: String, last: Int, before: String): CustomerConnection!
  customerByEmail(email: String!): Customer

  """
  Get a customer by its external ID. A customer's external ID is unique within a workspace.
  """
  customerByExternalId(externalId: ID!): Customer

  """Get a customer group by ID."""
  customerGroup(customerGroupId: ID!): CustomerGroup

  """Get a paginated list of customer groups."""
  customerGroups(filters: CustomerGroupsFilter, first: Int, after: String, last: Int, before: String): CustomerGroupConnection!
  threadFieldSchemas(first: Int, after: String, last: Int, before: String): ThreadFieldSchemaConnection!
  threadFieldSchema(threadFieldSchemaId: ID!): ThreadFieldSchema

  """
  Loads the customer's card instances.
  
  This query will return any cards that are loaded and within their expiry time.
  For cards that are past their expiry or are errored it will request a load of the cards and
  return a `CustomerCardInstanceLoading`.
  
  A maximum of 25 card instances will be returned, due to only allowing 25 customer card configs.
  """
  customerCardInstances(customerId: ID!, threadId: ID): [CustomerCardInstance!]!

  """
  Search for customers based on the provided query. Returned customers are sorted by how recently
  they changed status (most recent first).
  """
  searchCustomers(searchQuery: CustomersSearchQuery!, first: Int, after: String, last: Int, before: String): CustomerSearchConnection!
  snippets(first: Int, after: String, last: Int, before: String): SnippetConnection!
  snippet(snippetId: ID!): Snippet
  workspaceEmailSettings: WorkspaceEmailSettings!
  workspaceChatSettings: WorkspaceChatSettings!
  machineUser(machineUserId: ID!): MachineUser
  machineUsers(filters: MachineUsersFilter, first: Int, after: String, last: Int, before: String): MachineUserConnection!
  permissions: Permissions!
  workspaceMSTeamsInstallationInfo(redirectUrl: String!): WorkspaceMSTeamsInstallationInfo!
  workspaceMSTeamsIntegration: WorkspaceMSTeamsIntegration
  myMSTeamsInstallationInfo(redirectUrl: String!): UserMSTeamsInstallationInfo!
  myMSTeamsIntegration: UserMSTeamsIntegration
  workspaceSlackInstallationInfo(redirectUrl: String!): WorkspaceSlackInstallationInfo!
  workspaceSlackIntegrations(first: Int, after: String, last: Int, before: String): WorkspaceSlackIntegrationConnection!
  workspaceSlackIntegration(integrationId: ID!): WorkspaceSlackIntegration
  workspaceSlackChannelInstallationInfo(redirectUrl: String!): WorkspaceSlackChannelInstallationInfo!
  workspaceSlackChannelIntegration(integrationId: ID!): WorkspaceSlackChannelIntegration
  workspaceSlackChannelIntegrations(first: Int, after: String, last: Int, before: String): WorkspaceSlackChannelIntegrationConnection!
  workspaceDiscordChannelInstallationInfo(redirectUrl: String!): WorkspaceDiscordChannelInstallationInfo!
  workspaceDiscordChannelIntegration(integrationId: ID!): WorkspaceDiscordChannelIntegration
  workspaceDiscordChannelIntegrations(first: Int, after: String, last: Int, before: String): WorkspaceDiscordChannelIntegrationConnection!
  userAuthDiscordChannelIntegration(discordGuildId: String!): UserAuthDiscordChannelIntegration
  userAuthDiscordChannelIntegrations(first: Int, after: String, last: Int, before: String): UserAuthDiscordChannelIntegrationConnection!
  userAuthDiscordChannelInstallationInfo(redirectUrl: String!): UserAuthDiscordChannelInstallationInfo!

  """
  Searches for slack users in a thread based on a search term.
  The search term can be part of either the slack's handle or full name.
  """
  searchThreadSlackUsers(threadId: ID!, searchQuery: String!, first: Int, after: String, last: Int, before: String): SlackUserConnection!

  """
  Searches for slack users in a slack channel based on a search term.
  The search term can be part of either the slack's handle or full name.
  """
  searchSlackUsers(slackTeamId: String!, slackChannelId: String!, searchQuery: String!, first: Int, after: String, last: Int, before: String): SlackUserConnection!

  """
  Gets all slack channels for this workspace, which match the specified filters.
  """
  connectedSlackChannels(filters: ConnectedSlackChannelsFilter, first: Int, after: String, last: Int, before: String): ConnectedSlackChannelConnection!
  connectedSlackChannel(connectedSlackChannelId: ID!): ConnectedSlackChannel

  """Gets a single slack user within a thread based on their slack user ID."""
  threadSlackUser(threadId: ID!, slackUserId: ID!): SlackUser

  """
  Gets a single slack user within a channel based on their slack user ID.
  """
  slackUser(slackTeamId: String!, slackChannelId: String!, slackUserId: ID!): SlackUser
  userAuthSlackIntegration(slackTeamId: String!): UserAuthSlackIntegration
  userAuthSlackIntegrationByThreadId(threadId: ID!): UserAuthSlackIntegration
  userAuthSlackInstallationInfo(redirectUrl: String!, slackTeamId: String): UserAuthSlackInstallationInfo!
  workspaceDiscordIntegrations(first: Int, after: String, last: Int, before: String): WorkspaceDiscordIntegrationConnection!
  workspaceDiscordIntegration(integrationId: ID!): WorkspaceDiscordIntegration

  """
  Gets all Discord channels for this workspace, which match the specified filters.
  """
  connectedDiscordChannels(discordGuildId: String!, first: Int, after: String, last: Int, before: String): ConnectedDiscordChannelConnection!
  customerCardConfigs: [CustomerCardConfig!]!
  customerCardConfig(customerCardConfigId: ID!): CustomerCardConfig

  """Gets a single setting based on the code and the scope."""
  setting(code: String!, scope: SettingScopeInput!): Setting

  """List webhook versions."""
  webhookVersions(first: Int, after: String, last: Int, before: String): WebhookVersionConnection!

  """Gets a webhook target."""
  webhookTarget(webhookTargetId: ID!): WebhookTarget

  """List webhook targets."""
  webhookTargets(first: Int, after: String, last: Int, before: String): WebhookTargetConnection!

  """List all the events types you can subscribe to."""
  subscriptionEventTypes: [SubscriptionEventType!]!

  """Get a workflow rule by id."""
  workflowRule(workflowRuleId: ID!): WorkflowRule

  """List workflow rules."""
  workflowRules(first: Int, after: String, last: Int, before: String): WorkflowRuleConnection!

  """Get a chat app by id."""
  chatApp(chatAppId: ID!): ChatApp

  """List chat apps."""
  chatApps(first: Int, after: String, last: Int, before: String): ChatAppConnection!

  """Get a chat app secret by chat app id."""
  chatAppSecret(chatAppId: ID!): ChatAppHiddenSecret

  """Get a thread by its ID."""
  thread(threadId: ID!): Thread

  """Get a thread by its ref."""
  threadByRef(ref: String!): Thread

  """
  Get a thread by its external ID. A thread's external ID is unique within a customer, hence why the customer ID is required.
  """
  threadByExternalId(customerId: ID!, externalId: ID!): Thread
  threads(filters: ThreadsFilter, sortBy: ThreadsSort, first: Int, after: String, last: Int, before: String): ThreadConnection!
  searchThreads(searchQuery: ThreadsSearchQuery!, filters: ThreadsFilter, first: Int, after: String, last: Int, before: String): ThreadSearchResultConnection!
  autoresponder(autoresponderId: ID!): Autoresponder
  autoresponders(first: Int, after: String, last: Int, before: String): AutoresponderConnection!
  timeSeriesMetric(name: String!, options: TimeSeriesMetricOptions): TimeSeriesMetric
  singleValueMetric(name: String!, options: SingleValueMetricOptions): SingleValueMetric
  heatmapMetric(name: String!, options: HeatmapMetricOptionsInput): HeatmapMetric
  companies(first: Int, after: String, last: Int, before: String, filters: CompaniesFilter): CompanyConnection!
  company(companyId: ID!): Company
  searchCompanies(searchQuery: CompaniesSearchQuery!, filters: CompaniesFilter, first: Int, after: String, last: Int, before: String): CompanySearchResultConnection!
  tenants(first: Int, after: String, last: Int, before: String): TenantConnection!
  tenant(tenantId: ID!): Tenant
  searchTenants(searchQuery: TenantsSearchQuery!, first: Int, after: String, last: Int, before: String): TenantSearchResultConnection!
  threadDiscussion(threadDiscussionId: ID!): ThreadDiscussion
  serviceAuthorization(serviceAuthorizationId: ID!): ServiceAuthorization
  serviceAuthorizations(first: Int, after: String, last: Int, before: String, filters: ServiceAuthorizationsFilter): ServiceAuthorizationConnection!
  tiers(first: Int, after: String, last: Int, before: String): TierConnection!
  tier(tierId: ID!): Tier
  businessHours: BusinessHours @deprecated(reason: "Use businessHoursSlots instead.")
  businessHoursSlots: [BusinessHoursSlot!]!
  workspaceHmac: WorkspaceHmac
  threadLinkGroups(first: Int, after: String, last: Int, before: String, filters: ThreadLinkGroupFilter): ThreadLinkGroupConnection!

  """This API is in beta and may change without notice."""
  relatedThreads(threadId: ID!, variant: String): [ThreadWithDistance!]!

  """This API is in beta and may change without notice."""
  threadClusters(variant: String): [ThreadCluster!]!

  """This API is in beta and may change without notice."""
  generatedReplies(threadId: ID!, options: [GenerateReplyOption!]): [GeneratedReply!]
  indexedDocuments(first: Int, after: String, last: Int, before: String, filters: IndexedDocumentsFilter): IndexedDocumentConnection!
  knowledgeSources(first: Int, after: String, last: Int, before: String, filters: KnowledgeSourcesFilter): KnowledgeSourceConnection!
  savedThreadsViews(first: Int, after: String, last: Int, before: String): SavedThreadsViewConnection!
  savedThreadsView(savedThreadsViewId: ID!): SavedThreadsView
  searchThreadLinkCandidates(filters: ThreadLinkCandidateFilter!, searchQuery: String!, first: Int, after: String, last: Int, before: String): ThreadLinkCandidateConnection!
  helpCenters(first: Int, after: String, last: Int, before: String): HelpCenterConnection!
  helpCenter(id: ID!): HelpCenter
  helpCenterArticle(id: ID!): HelpCenterArticle
  helpCenterArticleGroup(id: ID!): HelpCenterArticleGroup
  helpCenterIndex(id: ID!): HelpCenterIndex

  """Get a help center article by its slug."""
  helpCenterArticleBySlug(helpCenterId: ID!, slug: String!): HelpCenterArticle

  """Get a help center article group by its slug."""
  helpCenterArticleGroupBySlug(helpCenterId: ID!, slug: String!): HelpCenterArticleGroup
  issueTrackerFields(issueTrackerType: String!, selectedFields: [SelectedIssueTrackerField!]!): [IssueTrackerField!]!
  customerSurveys(first: Int, after: String, last: Int, before: String): CustomerSurveyConnection!
  customerSurvey(id: ID!): CustomerSurvey
  escalationPaths(first: Int, after: String, last: Int, before: String): EscalationPathConnection!
  escalationPath(id: ID!): EscalationPath
}

type EscalationPath {
  id: ID!
  name: String!
  steps: [EscalationPathStep!]!
  description: String
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union EscalationPathStep = EscalationPathStepUser | EscalationPathStepLabelType

type EscalationPathStepLabelType {
  id: ID!
  labelType: LabelType!
}

type EscalationPathStepUser {
  id: ID!
  user: User!
}

type EscalationPathEdge {
  cursor: String!
  node: EscalationPath!
}

type EscalationPathConnection {
  edges: [EscalationPathEdge!]!
  pageInfo: PageInfo!
}

input SelectedIssueTrackerField {
  key: String!
  value: String!
}

enum IssueTrackerFieldType {
  SELECT
}

type IssueTrackerField {
  name: String!
  key: String!
  type: IssueTrackerFieldType!
  parentFieldKey: String
  options: [IssueTrackerFieldOption!]!
  selectedValue: String
  isRequired: Boolean!
}

type IssueTrackerFieldOption {
  name: String!
  value: String!
  icon: String
  color: String
}

input ThreadLinkCandidateFilter {
  sourceType: String!
}

type ThreadLinkCandidateConnection {
  edges: [ThreadLinkCandidateEdge!]!
  pageInfo: PageInfo!
}

type ThreadLinkCandidateEdge {
  cursor: String!
  node: ThreadLinkCandidate!
}

type ThreadLinkCandidate {
  sourceId: String!
  sourceType: String!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  sourceStatus: ThreadLinkSourceStatus
}

type ThreadLinkSourceStatus {
  key: String!
  label: String!
  color: String
  icon: String
}

type GeneratedReply {
  id: ID!
  markdown: String!
  timelineEntryId: ID
  text: String! @deprecated(reason: "Use markdown instead.")
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input GenerateReplyOption {
  key: String
  value: String
}

type ThreadCluster {
  id: ID!
  title: String!
  description: String!
  category: String!
  sentiment: String!
  emoji: String!
  meanDistance: Float!
  threads: [ThreadWithDistance!]!
}

type ThreadWithDistance {
  thread: Thread!
  distance: Float!
}

type Tier {
  id: ID!

  """The name of this tier."""
  name: String!

  """
  The external ID of this tier. You can use this field to store your own unique identifier for this tier. This must be unique in your workspace.
  """
  externalId: String

  """
  The color to assign to this tier, given by its hex code (e.g. #FABADA). This color is used in Plain's UI to represent this tier.
  """
  color: String!

  """
  If true, this tier will be applied to all threads that do not match any other tier. Only one tier can be the default tier.
  """
  isDefault: Boolean!

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it.
  """
  defaultPriority: Int! @deprecated(reason: "Use defaultThreadPriority instead.")

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it.
  """
  defaultThreadPriority: Int!
  memberships(first: Int, after: String, last: Int, before: String): TierMembershipConnection!
  serviceLevelAgreements: [ServiceLevelAgreement!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type TenantTierMembership {
  id: ID!
  tierId: ID!
  tenantId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CompanyTierMembership {
  id: ID!
  tierId: ID!
  companyId: ID!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union TierMembership = TenantTierMembership | CompanyTierMembership

type TierMembershipEdge {
  cursor: String!
  node: TierMembership!
}

type TierMembershipConnection {
  edges: [TierMembershipEdge!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

type ServiceLevelAgreementThreadLabelTypeIdFilter {
  """
  The label type IDs that the thread needs to have in order for the SLA to be applied. Based on the 'requireAll' field.
  """
  labelTypeIds: [ID!]!

  """
  If true, the SLA will only be applied to threads that have all of the provided label types. If false, the SLA will be applied to threads that have any of the provided label types.
  """
  requireAll: Boolean!
}

interface ServiceLevelAgreement {
  id: ID!

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: Boolean!

  """
  This SLA can only be applied to a thread if it has one of these priority values.
  """
  threadPriorityFilter: [Int!]!

  """
  This SLA can only be applied to a thread if it has one of these label types.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter

  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type FirstResponseTimeServiceLevelAgreement implements ServiceLevelAgreement {
  id: ID!

  """
  This SLA will breach if it does not receive a first response within this many minutes.
  """
  firstResponseTimeMinutes: Int!
  useBusinessHoursOnly: Boolean!
  threadPriorityFilter: [Int!]!
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type NextResponseTimeServiceLevelAgreement implements ServiceLevelAgreement {
  id: ID!

  """
  This SLA will breach if it does not receive a next response within this many minutes.
  """
  nextResponseTimeMinutes: Int!
  useBusinessHoursOnly: Boolean!
  threadPriorityFilter: [Int!]!
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilter
  breachActions: [BreachAction!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union BreachAction = BeforeBreachAction

type BeforeBreachAction {
  beforeBreachMinutes: Int!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type TierEdge {
  cursor: String!
  node: Tier!
}

type TierConnection {
  edges: [TierEdge!]!
  pageInfo: PageInfo!
}

input CustomerGroupsFilter {
  externalIds: [String!]
}

input CustomerGroupMembershipsFilter {
  customerGroupExternalIds: [String!]
}

enum MetricDimensionType {
  COMPANY
  CUSTOMER_GROUP
  LABEL_TYPE
  MESSAGE_SOURCE
  PRIORITY
  THREAD_FIELD
  TIER
}

type MetricDimension {
  type: MetricDimensionType!
  value: String!
}

input SingleValueMetricFilters {
  userId: ID
  csatRating: Int
  csatSurveyId: ID
}

input SingleValueMetricOptions {
  """Defaults to 24 hours ago."""
  from: String
  to: String
  dimension: MetricDimensionType
  subDimension: String
  filters: SingleValueMetricFilters
}

type SingleValueMetricValue {
  value: Float
  dimension: MetricDimension
  userId: ID
}

type SingleValueMetric {
  values: [SingleValueMetricValue!]!
}

type HeatmapHour {
  percentage: Float!
  total: Int!
  threadIds: [String!]!
}

type HeatmapMetric {
  days: [[HeatmapHour!]!]!
}

input HeatmapMetricOptionsInput {
  from: String
  to: String
  dimensionType: MetricDimensionType
  dimensionValue: String
  subDimension: String
}

enum TimeSeriesMetricDimensionType {
  COMPANY
  CUSTOMER_GROUP
  LABEL_TYPE
  MESSAGE_SOURCE
  PRIORITY
  THREAD_FIELD
  TIER
}

enum TimeSeriesMetricIntervalUnit {
  HOUR
  DAY
  WEEK
  MONTH
  QUARTER
}

input TimeSeriesMetricInterval {
  unit: TimeSeriesMetricIntervalUnit
}

input TimeSeriesMetricFilters {
  userId: ID
  csatRating: Int
  csatSurveyId: ID
}

input TimeSeriesMetricOptions {
  """Defaults to 24 hours ago."""
  from: String
  to: String
  dimension: TimeSeriesMetricDimensionType
  subDimension: String
  interval: TimeSeriesMetricInterval
  filters: TimeSeriesMetricFilters
  fetchThreadIds: Boolean
}

type TimeSeriesMetric {
  timestamps: [DateTime!]!
  series: [TimeSeriesSeries!]!
}

type TimeSeriesSeries {
  values: [Float]!
  userId: ID
  dimension: TimeSeriesMetricDimension
  threadIds: [[String]]
}

type TimeSeriesMetricDimension {
  type: TimeSeriesMetricDimensionType!
  value: String!
}

input TierIdentifierInput {
  tierId: ID
  externalId: String
}

input ThreadFieldFilter {
  key: String!
  stringValue: String
  booleanValue: Boolean
}

input DatetimeFilter {
  """
  Timestamps -greater or equal- than this value. ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  after: String

  """
  Timestamps -less- than this value. ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  before: String
}

enum SentimentType {
  POSITIVE
  NEGATIVE
  NEUTRAL
}

input SurveyResponseFilter {
  """
  Filter for threads with any survey response, regardless of the specific values
  """
  hasResponse: Boolean
  sentiment: SentimentType
  rating: Int
  surveyId: ID
  responseAt: DatetimeFilter
}

input ThreadsFilter {
  threadIds: [ID!]
  refs: [String!]
  labelTypeIds: [ID!]
  priorities: [Int!]
  customerIds: [ID!]
  isAssigned: Boolean
  assignedToUser: [ID!]
  isMarkedAsSpam: Boolean
  supportEmailAddresses: [String!]
  customerGroupIdentifiers: [CustomerGroupIdentifier!]
  serviceLevelAgreements: ServiceLevelAgreementFilter
  tierIdentifiers: [TierIdentifierInput!]
  threadFields: [ThreadFieldFilter!]
  tenantIdentifiers: [TenantIdentifierInput!]
  companyIdentifiers: [CompanyIdentifierInput!]
  messageSource: [MessageSource!]
  participantIds: [ID!]
  statusChangedAt: DatetimeFilter
  statuses: [ThreadStatus!]
  statusDetails: [StatusDetailType!]
  threadLinkGroupIds: [ID!]
  createdAt: DatetimeFilter
  updatedAt: DatetimeFilter
  surveyResponse: SurveyResponseFilter
}

enum ServiceLevelAgreementType {
  FIRST_RESPONSE_TIME
  NEXT_RESPONSE_TIME
}

input ServiceLevelAgreementFilter {
  types: [ServiceLevelAgreementType!]
  statuses: [ServiceLevelAgreementStatus!]
  updatedAt: DatetimeFilter
}

enum ThreadsSortField {
  STATUS_CHANGED_AT
  CREATED_AT
  CLOSEST_TO_BREACH_SLA
  LAST_INBOUND_MESSAGE_AT
  PRIORITY
}

input ThreadsSort {
  field: ThreadsSortField!
  direction: SortDirection!
}

type ThreadConnection {
  pageInfo: PageInfo!
  edges: [ThreadEdge!]!
  totalCount: Int!
}

type ThreadEdge {
  cursor: String!
  node: Thread!
}

"""An enum for why the mutation failed overall."""
enum MutationErrorType {
  """
  Input validation failed, see the `fields` for details on why the input was invalid.
  """
  VALIDATION

  """
  The user is not authorized to do this mutation. See `message` for details on which permissions are missing.
  """
  FORBIDDEN

  """
  An unknown internal server error occurred. Retry the mutation and if it persists, please email help@plain.com
  """
  INTERNAL
}

"""An enum specific to each field, explaining why validation failed."""
enum MutationFieldErrorType {
  """
  The field was provided, but didn't pass the requirements of the field. See `message` for details on why.
  """
  VALIDATION

  """
  The field is required to be provided. String inputs may be trimmed and checked for emptiness.
  """
  REQUIRED

  """The input field referenced an entity that wasn't found."""
  NOT_FOUND
}

"""
A type indicating an error has occurred with a specific field in the input.
"""
type MutationFieldError {
  """The name of the field for which the error happened."""
  field: String!

  """
  An English technical description of the error. This error is usually meant to be read by a developer and not an end user.
  """
  message: String!

  """
  The type of the error. Can be used to display a user friendly error message.
  """
  type: MutationFieldErrorType!
}

"""A type indicating an error has occurred while making a mutation."""
type MutationError {
  """
  An English technical description of the error. This error is usually meant to be read by a developer and not an end user.
  """
  message: String!

  """
  The type of error. Can be used to display a user friendly error message.
  """
  type: MutationErrorType!

  """
  A fixed error code that can be used to handle this error, see https://www.plain.com/docs/graphql-api/error-codes for a description of each code.
  """
  code: String!

  """The array of fields that are impacted by this error."""
  fields: [MutationFieldError!]!
}

input StringInput {
  value: String!
}

input IntInput {
  value: Int!
}

input BooleanInput {
  value: Boolean!
}

input OptionalStringInput {
  value: String
}

input OptionalBooleanInput {
  value: Boolean
}

input CreateUserAccountInput {
  fullName: String!
  publicName: String!
  marketingConsent: Boolean
}

type CreateUserAccountOutput {
  userAccount: UserAccount
  error: MutationError
}

input CreateWorkspaceInput {
  name: String!
  publicName: String!
}

type CreateWorkspaceOutput {
  workspace: Workspace
  error: MutationError
}

input InviteUserToWorkspaceInput {
  email: String!
  roleIds: [ID!] @deprecated(reason: "Use roleKey instead.")
  roleKey: RoleKey
  usingBillingRotaSeat: BooleanInput
}

type InviteUserToWorkspaceOutput {
  invite: WorkspaceInvite
  error: MutationError
}

input AcceptWorkspaceInviteInput {
  inviteId: ID!
}

type AcceptWorkspaceInviteOutput {
  invite: WorkspaceInvite
  error: MutationError
}

input DeleteWorkspaceInviteInput {
  inviteId: ID!
}

type DeleteWorkspaceInviteOutput {
  invite: WorkspaceInvite
  error: MutationError
}

input AssignRolesToUserInput {
  userId: ID!
  roleIds: [ID!] @deprecated(reason: "Use roleKey instead.")
  roleKey: RoleKey
  usingBillingRotaSeat: BooleanInput
}

type AssignRolesToUserOutput {
  error: MutationError
}

input CreateLabelTypeInput {
  name: String!
  icon: String
  color: String
  type: LabelTypeType
  description: String
  parentLabelTypeId: ID
}

type CreateLabelTypeOutput {
  labelType: LabelType
  error: MutationError
}

input ArchiveLabelTypeInput {
  labelTypeId: ID!
}

type ArchiveLabelTypeOutput {
  labelType: LabelType
  error: MutationError
}

input UnarchiveLabelTypeInput {
  labelTypeId: ID!
}

type UnarchiveLabelTypeOutput {
  labelType: LabelType
  error: MutationError
}

input UpdateLabelTypeInput {
  labelTypeId: ID!
  name: StringInput
  icon: OptionalStringInput
  color: OptionalStringInput
  description: OptionalStringInput
}

type UpdateLabelTypeOutput {
  labelType: LabelType
  error: MutationError
}

input AddLabelsInput {
  labelTypeIds: [ID!]!
  threadId: ID!
}

type AddLabelsOutput {
  labels: [Label!]!
  thread: Thread
  error: MutationError
}

input AddLabelsToUserInput {
  labelTypeIds: [ID!]!
  entityId: ID!
}

type AddLabelsToUserOutput {
  labels: [Label!]!
  user: User
  error: MutationError
}

input RemoveLabelsInput {
  labelIds: [ID!]!
}

type RemoveLabelsOutput {
  thread: Thread
  error: MutationError
}

input RemoveLabelsFromUserInput {
  labelIds: [ID!]!
}

type RemoveLabelsFromUserOutput {
  labels: [Label!]!
  user: User
  error: MutationError
}

input DependsOnThreadFieldInput {
  threadFieldSchemaId: ID!
  threadFieldSchemaValue: String!
}

input OptionalDependsOnThreadFieldInput {
  value: DependsOnThreadFieldInput
}

input CreateThreadFieldSchemaInput {
  label: String!
  key: String!
  description: String!
  order: Int!
  type: ThreadFieldSchemaType!
  enumValues: [String!]!
  isRequired: Boolean!
  defaultStringValue: String
  defaultBooleanValue: Boolean
  isAiAutoFillEnabled: Boolean!
  dependsOnThreadField: DependsOnThreadFieldInput
  dependsOnLabelTypeIds: [ID!]
}

type CreateThreadFieldSchemaOutput {
  threadFieldSchema: ThreadFieldSchema
  error: MutationError
}

input UpdateThreadFieldSchemaInput {
  threadFieldSchemaId: ID!
  label: StringInput
  description: StringInput
  order: Int
  enumValues: [String!]
  isRequired: Boolean
  defaultStringValue: OptionalStringInput
  defaultBooleanValue: OptionalBooleanInput
  isAiAutoFillEnabled: Boolean
  dependsOnThreadField: OptionalDependsOnThreadFieldInput
  dependsOnLabelTypeIds: [ID!]
}

type UpdateThreadFieldSchemaOutput {
  threadFieldSchema: ThreadFieldSchema
  error: MutationError
}

input DeleteThreadFieldSchemaInput {
  threadFieldSchemaId: ID!
}

type DeleteThreadFieldSchemaOutput {
  error: MutationError
}

input DeleteEscalationPathInput {
  escalationPathId: ID!
}

type DeleteEscalationPathOutput {
  error: MutationError
}

input CreateEscalationPathInput {
  name: String!
  description: String
  steps: [EscalationPathStepInput!]!
}

type CreateEscalationPathOutput {
  escalationPath: EscalationPath
  error: MutationError
}

input UpdateEscalationPathInput {
  escalationPathId: ID!
  name: String
  description: String
  steps: [EscalationPathStepInput!]
}

type UpdateEscalationPathOutput {
  escalationPath: EscalationPath
  error: MutationError
}

input EscalationPathStepInput {
  type: EscalationPathStepType!
  userId: ID
  labelTypeId: ID
}

enum EscalationPathStepType {
  USER
  LABEL_TYPE
}

input ThreadFieldSchemaOrderInput {
  threadFieldSchemaId: ID!
  order: Int!
}

input ReorderThreadFieldSchemasInput {
  threadFieldSchemaOrders: [ThreadFieldSchemaOrderInput!]!
}

type ReorderThreadFieldSchemasOutput {
  threadFieldSchemas: [ThreadFieldSchema!]
  error: MutationError
}

input UpsertThreadFieldIdentifier {
  threadId: ID!
  key: String!
}

input UpsertThreadFieldInput {
  identifier: UpsertThreadFieldIdentifier!
  type: ThreadFieldSchemaType!
  stringValue: String
  booleanValue: Boolean
}

input CreateThreadFieldOnThreadInput {
  key: String!
  type: ThreadFieldSchemaType!
  stringValue: String
  booleanValue: Boolean
}

type UpsertThreadFieldOutput {
  threadField: ThreadField
  result: UpsertResult
  error: MutationError
}

type BulkUpsertThreadFieldResult {
  threadField: ThreadField
  result: UpsertResult
}

input BulkUpsertThreadFieldsInput {
  inputs: [UpsertThreadFieldInput!]!
}

type BulkUpsertThreadFieldsOutput {
  results: [BulkUpsertThreadFieldResult!]!
  error: MutationError
}

input DeleteThreadFieldIdentifier {
  threadId: ID!
  key: String!
}

input DeleteThreadFieldInput {
  identifier: DeleteThreadFieldIdentifier!
}

type DeleteThreadFieldOutput {
  error: MutationError
}

input CreateWorkflowRuleInput {
  name: String!

  """JSON-encoded payload of the rule definition."""
  payload: String!
}

type CreateWorkflowRuleOutput {
  workflowRule: WorkflowRule
  error: MutationError
}

input UpdateWorkflowRuleInput {
  workflowRuleId: ID!
  name: StringInput

  """JSON-encoded payload of the rule definition."""
  payload: StringInput
}

type UpdateWorkflowRuleOutput {
  workflowRule: WorkflowRule
  error: MutationError
}

input ToggleWorkflowRulePublishedInput {
  workflowRuleId: ID!
}

type ToggleWorkflowRulePublishedOutput {
  workflowRule: WorkflowRule
  error: MutationError
}

input DeleteWorkflowRuleInput {
  workflowRuleId: ID!
}

type DeleteWorkflowRuleOutput {
  error: MutationError
}

input WorkspaceFileInput {
  workspaceFileId: ID
}

input CreateChatAppInput {
  name: String!
  logo: WorkspaceFileInput
}

type CreateChatAppOutput {
  chatApp: ChatApp
  error: MutationError
}

input UpdateChatAppInput {
  chatAppId: ID!
  name: StringInput
  logo: WorkspaceFileInput
}

type UpdateChatAppOutput {
  chatApp: ChatApp
  error: MutationError
}

input DeleteChatAppInput {
  chatAppId: ID!
}

type DeleteChatAppOutput {
  error: MutationError
}

input CreateChatAppSecretInput {
  chatAppId: ID!
}

type CreateChatAppSecretOutput {
  chatAppSecret: ChatAppSecret
  error: MutationError
}

input DeleteChatAppSecretInput {
  chatAppId: ID!
}

type DeleteChatAppSecretOutput {
  error: MutationError
}

"""
Represents a simplified, high-level status of a thread link which can be used for filtering and sorting.
Statuses from different external providers (e.g. Linear, Jira, Incident.io, Notion... etc) are mapped to one of these values.
"""
enum ThreadLinkStatus {
  """
  Indicates that the linked entity is in pre-start state.
  This includes granular statuses like "Backlog", "Triage", "Unstarted", "Draft", "Planned", ...etc
  """
  TODO

  """
  Indicates that the linked entity is in a post-start state, but not yet finished.
  This includes granular statuses like "Started", "In Progress", "In Review", "Blocked", ...etc
  """
  IN_PROGRESS

  """
  Indicates that the linked issue is in a state that is considered finished.
  This includes granular statuses like "Completed", "Done", "Resolved", "Cancelled", ...etc.
  """
  DONE

  """Unknown or unsupported future statuses from external providers."""
  UNKNOWN
}

interface ThreadLink {
  id: ID!
  threadId: ID!
  sourceId: String!
  sourceType: String!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

"""
Represents the possible states of a Linear issue, sourced from the Linear API.
Reference: https://studio.apollographql.com/public/Linear-API/variant/current/schema/reference/objects/WorkflowState#type
"""
enum LinearIssueStateType {
  TRIAGE
  BACKLOG
  UNSTARTED
  STARTED
  COMPLETED
  CANCELLED

  """Placeholder for unknown or unsupported future states from Linear."""
  UNKNOWN
}

type LinearIssueState {
  type: LinearIssueStateType!
  label: String!
  color: String!
}

type LinearIssueThreadLink implements ThreadLink {
  id: ID!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  threadId: ID!
  sourceId: String!
  sourceType: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  linearIssueId: ID!
  linearIssueIdentifier: String!
  linearIssueState: LinearIssueState!
  linearIssueCreatedAt: DateTime!
  linearIssueUpdatedAt: DateTime!
  linearIssueUrl: String! @deprecated(reason: "Use url instead.")
}

type JiraIssueType {
  name: String!
  iconUrl: String!
}

type JiraIssueThreadLink implements ThreadLink {
  id: ID!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  threadId: ID!
  sourceId: String!
  sourceType: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  jiraIssueId: ID!
  jiraIssueKey: String!
  jiraIssueType: JiraIssueType!
}

type PlainThreadThreadLink implements ThreadLink {
  id: ID!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  threadId: ID!
  sourceId: String!
  sourceType: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  plainThreadId: ID!
  plainThreadStatusDetailType: StatusDetailType!
}

type GenericThreadLink implements ThreadLink {
  id: ID!
  title: String!
  description: String
  url: String!
  status: ThreadLinkStatus!
  threadId: ID!
  sourceId: String!
  sourceType: String!
  sourceStatus: ThreadLinkSourceStatus
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input LinearIssueThreadLinkInput {
  linearIssueId: ID!
  linearIssueUrl: String!
}

input PlainThreadLinkInput {
  plainThreadId: ID!
}

input JiraIssueThreadLinkInput {
  jiraIssueId: ID!
}

input CreateThreadLinkInput {
  threadId: ID!
  sourceId: String
  sourceType: String
  linearIssue: LinearIssueThreadLinkInput
  plainThread: PlainThreadLinkInput
  jiraIssue: JiraIssueThreadLinkInput
}

type CreateThreadLinkOutput {
  threadLink: ThreadLink
  error: MutationError
}

input DeleteThreadLinkInput {
  threadLinkId: ID!
}

type DeleteThreadLinkOutput {
  error: MutationError
}

type ThreadLinkEdge {
  cursor: String!
  node: ThreadLink!
}

type ThreadLinkConnection {
  edges: [ThreadLinkEdge!]!
  pageInfo: PageInfo!
  totalCount: Int
}

type ThreadLinkGroupAggregateMetrics {
  totalCount: Int!
}

type ThreadLinkGroupSingleTierMetrics {
  tier: Tier!
  metrics: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroupSingleCompanyMetrics {
  company: Company!
  metrics: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroupTierMetrics {
  byTier: [ThreadLinkGroupSingleTierMetrics!]!

  """Metrics when the thread is not associated with any tier."""
  noTier: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroupCompanyMetrics {
  byCompany: [ThreadLinkGroupSingleCompanyMetrics!]!

  """Metrics when the thread is not associated with any company."""
  noCompany: ThreadLinkGroupAggregateMetrics!
}

type ThreadLinkGroup {
  id: ID!
  threads(first: Int, after: String, last: Int, before: String): ThreadConnection!
  threadLinks(first: Int, after: String, last: Int, before: String): ThreadLinkConnection!
  tierMetrics: ThreadLinkGroupTierMetrics!
  companyMetrics: ThreadLinkGroupCompanyMetrics!

  """
  The default rank of the thread link group which takes into account
  only active groups. This rank is not affected by input filters.
  """
  defaultViewRank: Int

  """
  The current rank of the thread link group considering groups
  which match the non-ID input filters.
  """
  currentViewRank: Int!
}

type ThreadLinkGroupEdge {
  cursor: String!
  node: ThreadLinkGroup!
}

type ThreadLinkGroupConnection {
  edges: [ThreadLinkGroupEdge!]!
  pageInfo: PageInfo!
}

input ThreadLinkGroupFilter {
  """Defaults to [TODO, IN_PROGRESS]"""
  statuses: [ThreadLinkStatus!]
  threadLinkGroupIds: [ID!]
  companyIds: [ID!]
  tierIds: [ID!]
}

input CreateNoteInput {
  customerId: ID!
  threadId: ID
  text: String!
  markdown: String
  attachmentIds: [ID!]
}

type CreateNoteOutput {
  note: Note
  error: MutationError
}

input DeleteNoteInput {
  noteId: ID!
}

type DeleteNoteOutput {
  note: Note
  error: MutationError
}

input ThreadsDisplayOptionsInput {
  hasStatus: Boolean!
  hasCustomer: Boolean!
  hasCompany: Boolean!
  hasPreviewText: Boolean!
  hasTier: Boolean!
  hasCustomerGroups: Boolean!
  hasLabels: Boolean!
  hasLinearIssues: Boolean @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasJiraIssues: Boolean @deprecated(reason: "Use hasIssueTrackerIssues instead")
  hasLinkedThreads: Boolean!
  hasServiceLevelAgreements: Boolean!
  hasChannels: Boolean!
  hasLastUpdated: Boolean!
  hasAssignees: Boolean!
  hasIssueTrackerIssues: Boolean
}

input SavedThreadsViewFilterInput {
  statuses: [ThreadStatus!]!
  statusDetails: [StatusDetailType!]!
  priorities: [Int!]!
  assignedToUser: [ID!]!
  participants: [ID!]!
  customerGroups: [ID!]!
  companies: [ID!]!
  tenants: [ID!]!
  tiers: [ID!]!
  labelTypeIds: [ID!]!
  messageSource: [MessageSource!]!
  supportEmailAddresses: [String!]!
  slaTypes: [String!]!
  slaStatuses: [String!]!
  threadFields: [ThreadFieldFilter!]!
  threadLinkGroupIds: [ID!]!
  sort: ThreadsSort!
  displayOptions: ThreadsDisplayOptionsInput!
  groupBy: ThreadsGroupBy!
  layout: ThreadsLayout!
}

input CreateSavedThreadsViewInput {
  name: String!
  icon: String!
  color: String!
  threadsFilter: SavedThreadsViewFilterInput!
}

type CreateSavedThreadsViewOutput {
  savedThreadsView: SavedThreadsView
  error: MutationError
}

input DeleteSavedThreadsViewInput {
  savedThreadsViewId: ID!
}

type DeleteSavedThreadsViewOutput {
  error: MutationError
}

input UpdateSavedThreadsViewInput {
  savedThreadsViewId: ID!
  name: StringInput
  icon: StringInput
  color: StringInput
  threadsFilter: SavedThreadsViewFilterInput
}

type UpdateSavedThreadsViewOutput {
  savedThreadsView: SavedThreadsView
  error: MutationError
}

input CreateMyFavoritePageInput {
  key: String!
}

type CreateMyFavoritePageOutput {
  favoritePage: FavoritePage
  error: MutationError
}

input DeleteMyFavoritePageInput {
  favoritePageId: ID!
}

type DeleteMyFavoritePageOutput {
  error: MutationError
}

input CreateSnippetInput {
  name: String!
  text: String!
  markdown: String

  """Used to group snippets, only accepts alphanumeric characters"""
  path: String
}

type CreateSnippetOutput {
  snippet: Snippet
  error: MutationError
}

input DeleteSnippetInput {
  snippetId: ID!
}

type DeleteSnippetOutput {
  snippet: Snippet
  error: MutationError
}

input UpdateSnippetInput {
  snippetId: ID!
  name: StringInput
  text: StringInput
  markdown: StringInput

  """Used to group snippets, only accepts alphanumeric characters"""
  path: OptionalStringInput
}

type UpdateSnippetOutput {
  snippet: Snippet
  error: MutationError
}

input SendChatInput {
  customerId: ID!
  text: String
  attachmentIds: [ID!]
  threadId: ID

  """
  When provided, this will override the timestamp of the chat. Useful when backfilling messages. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type SendChatOutput {
  chat: Chat
  error: MutationError
}

input SendCustomerChatInput {
  customerId: ID!
  text: String
  attachmentIds: [ID!]
  threadId: ID!

  """
  When provided, this will override the timestamp of the chat. Useful when backfilling messages. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type SendCustomerChatOutput {
  chat: Chat
  error: MutationError
}

input ChangeUserStatusInput {
  userId: ID!
  status: UserStatus!
}

type ChangeUserStatusOutput {
  user: User
  error: MutationError
}

input UpdateMyUserInput {
  fullName: OptionalStringInput
  publicName: OptionalStringInput
}

type UpdateMyUserOutput {
  user: User
  error: MutationError
}

input UpdateWorkspaceInput {
  publicName: StringInput
  name: StringInput
  logo: WorkspaceFileInput
  domainNames: [String!]
}

type UpdateWorkspaceOutput {
  workspace: Workspace
  error: MutationError
}

input DeleteUserInput {
  userId: ID!
}

type DeleteUserOutput {
  error: MutationError
}

type DnsRecord {
  type: String!
  name: String!
  value: String!
  isVerified: Boolean!
  verifiedAt: DateTime
  lastCheckedAt: DateTime
}

type WorkspaceEmailDomainSettings {
  domainName: String!
  supportEmailAddress: String!

  """
  The list of alternate email addresses that can be used to send emails to and from the workspace.
  Limited to 5.
  
  e.g. [info@plain.com, help@plain.com].
  """
  alternateSupportEmailAddresses: [String!]!
  isForwardingConfigured: Boolean!
  inboundForwardingEmail: String!
  isDomainConfigured: Boolean!
  dkimDnsRecord: DnsRecord!
  returnPathDnsRecord: DnsRecord!
}

type WorkspaceEmailSettings {
  isEnabled: Boolean!
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  bccEmail: String
}

input AddWorkspaceAlternateSupportEmailAddressInput {
  alternateSupportEmailAddress: String!
}

type AddWorkspaceAlternateSupportEmailAddressOutput {
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  error: MutationError
}

input RemoveWorkspaceAlternateSupportEmailAddressInput {
  alternateSupportEmailAddress: String!
}

type RemoveWorkspaceAlternateSupportEmailAddressOutput {
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  error: MutationError
}

input CreateWorkspaceEmailDomainSettingsInput {
  supportEmailAddress: String!
}

type CreateWorkspaceEmailDomainSettingsOutput {
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  error: MutationError
}

type DeleteWorkspaceEmailDomainSettingsOutput {
  error: MutationError
}

input VerifyWorkspaceEmailForwardingSettingsInput {
  isForwardingConfigured: Boolean!
}

type VerifyWorkspaceEmailForwardingSettingsOutput {
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  error: MutationError
}

type VerifyWorkspaceEmailDnsSettingsOutput {
  workspaceEmailDomainSettings: WorkspaceEmailDomainSettings
  error: MutationError
}

input UpdateWorkspaceEmailSettingsInput {
  isEnabled: Boolean!
}

type UpdateWorkspaceEmailSettingsOutput {
  workspaceEmailSettings: WorkspaceEmailSettings
  error: MutationError
}

type WorkspaceChatSettings {
  isEnabled: Boolean!
}

input EmailParticipantInput {
  name: String
  email: String!
}

input SendNewEmailInput {
  customerId: ID!
  subject: String!
  textContent: String!
  markdownContent: String
  attachmentIds: [ID!]
  additionalRecipients: [EmailParticipantInput!]
  hiddenRecipients: [EmailParticipantInput!]

  """
  Optional field for alternate from email address. If provided, it will be used as the from address in the email.
  It must match one of the workspace support email addresses (default or alternate).
  """
  fromAlternateSupportEmail: EmailParticipantInput

  """
  If provided this will add the new email to an existing thread. If not provided, a new thread will be created.
  """
  threadId: ID
}

input SendBulkEmailInput {
  threadIds: [ID!]!
  textContent: String!
  markdownContent: String
}

input ReplyToEmailInput {
  customerId: ID @deprecated(reason: "Use inReplyToEmailId instead.")
  inReplyToEmailId: ID!
  subject: String
  textContent: String!
  markdownContent: String
  attachmentIds: [ID!]
  additionalRecipients: [EmailParticipantInput!]
  hiddenRecipients: [EmailParticipantInput!]

  """
  Optional field for alternate from email address. If provided, it will be used as the from address in the email.
  It must match one of the workspace support email addresses (default or alternate).
  """
  fromAlternateSupportEmail: EmailParticipantInput
}

type Email {
  id: ID!
  thread: Thread
  customer: Customer!
  inReplyToEmailId: ID
  from: EmailParticipant!
  to: EmailParticipant!
  subject: String
  textContent: String
  markdownContent: String
  attachments: [Attachment!]!
  additionalRecipients: [EmailParticipant!]!
  hiddenRecipients: [EmailParticipant!]!
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type SendNewEmailOutput {
  email: Email
  error: MutationError
}

type ReplyToEmailOutput {
  email: Email
  error: MutationError
}

type SendBulkEmailOutput {
  error: MutationError
}

input CreateEmailPreviewUrlInput {
  emailId: ID!
  customerId: ID!
}

type EmailPreviewUrl {
  previewUrl: String!
  expiresAt: DateTime!
}

type CreateEmailPreviewUrlOutput {
  emailPreviewUrl: EmailPreviewUrl
  error: MutationError
}

input CreateAttachmentDownloadUrlInput {
  attachmentId: ID!
}

type AttachmentDownloadUrl {
  attachment: Attachment!
  downloadUrl: String!
  expiresAt: DateTime!
}

enum AttachmentVirusScanResult {
  """The attachment is clean and safe to download."""
  CLEAN

  """The attachment is infected and should not be downloaded."""
  INFECTED

  """The virus scan failed."""
  FAILED

  """The virus scan is still pending."""
  PENDING
}

type CreateAttachmentDownloadUrlOutput {
  attachmentDownloadUrl: AttachmentDownloadUrl

  """
  The result of the virus scan on this attachment. If this is null, it means that your workspace does not have virus scan checks enabled.
  """
  attachmentVirusScanResult: AttachmentVirusScanResult
  error: MutationError
}

enum AttachmentType {
  EMAIL
  CUSTOM_TIMELINE_ENTRY
  CHAT
  SLACK
  THREAD_DISCUSSION
  MS_TEAMS
  DISCORD
  NOTE
}

input CreateAttachmentUploadUrlInput {
  customerId: ID!
  fileName: String!
  fileSizeBytes: Int!
  attachmentType: AttachmentType!
}

type UploadFormData {
  key: String!
  value: String!
}

type AttachmentUploadUrl {
  attachment: Attachment!
  uploadFormUrl: String!
  uploadFormData: [UploadFormData!]!
  expiresAt: DateTime!
}

type CreateAttachmentUploadUrlOutput {
  attachmentUploadUrl: AttachmentUploadUrl
  error: MutationError
}

input ComponentTextInput {
  """
  The text content, with markdown support. Must be between 1 and 5000 characters.
  """
  text: String!
  textSize: ComponentTextSize
  textColor: ComponentTextColor
  color: ComponentTextColor @deprecated(reason: "use textColor instead")
  size: ComponentTextSize @deprecated(reason: "use textSize instead")
}

input ComponentPlainTextInput {
  """
  The text content, without markdown support. Must be between 1 and 5000 characters.
  """
  plainText: String!
  plainTextSize: ComponentPlainTextSize
  plainTextColor: ComponentPlainTextColor
}

input ComponentLinkButtonInput {
  """Must be a valid URL."""
  linkButtonUrl: String

  """The label of the button. Maximum 500 characters."""
  linkButtonLabel: String
  url: String @deprecated(reason: "use linkButtonUrl instead")
  label: String @deprecated(reason: "use linkButtonLabel instead")
}

input ComponentBadgeInput {
  """The label of the badge. Maximum 500 characters."""
  badgeLabel: String!
  badgeColor: ComponentBadgeColor
}

input ComponentCopyButtonInput {
  """The value to be copied. Maximum 1000 characters."""
  copyButtonValue: String!

  """The tooltip label. Maximum 500 characters."""
  copyButtonTooltipLabel: String
}

input ComponentRowInput {
  """Must contain at least one component."""
  rowMainContent: [ComponentRowContentInput!]!
  rowAsideContent: [ComponentRowContentInput!]!
}

input ComponentContainerInput {
  """Must contain at least one component."""
  containerContent: [ComponentContainerContentInput!]!
}

input ComponentDividerInput {
  dividerSpacingSize: ComponentDividerSpacingSize
  spacingSize: ComponentDividerSpacingSize @deprecated(reason: "use dividerSpacingSize instead")
}

input ComponentSpacerInput {
  """
  Required input, will be made required after deprecated fields are removed.
  """
  spacerSize: ComponentSpacerSize
  size: ComponentSpacerSize @deprecated(reason: "use spacerSize instead")
}

input ComponentContainerContentInput {
  componentText: ComponentTextInput
  componentPlainText: ComponentPlainTextInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentSpacer: ComponentSpacerInput
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentRow: ComponentRowInput
}

input ComponentRowContentInput {
  componentText: ComponentTextInput
  componentPlainText: ComponentPlainTextInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentSpacer: ComponentSpacerInput
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
}

input ComponentInput {
  componentText: ComponentTextInput
  componentPlainText: ComponentPlainTextInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentSpacer: ComponentSpacerInput
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentRow: ComponentRowInput
  componentContainer: ComponentContainerInput
}

input EventComponentInput {
  componentText: ComponentTextInput
  componentPlainText: ComponentPlainTextInput
  componentDivider: ComponentDividerInput
  componentLinkButton: ComponentLinkButtonInput
  componentSpacer: ComponentSpacerInput
  componentBadge: ComponentBadgeInput
  componentCopyButton: ComponentCopyButtonInput
  componentRow: ComponentRowInput
}

enum UpsertResult {
  UPDATED
  CREATED
  NOOP
}

input EmailAddressInput {
  email: String!
  isVerified: Boolean!
}

input UpsertCustomerIdentifierInput {
  externalId: ID
  emailAddress: String
  customerId: ID
}

input UpsertCustomerOnCreateInput {
  externalId: ID
  fullName: String!
  shortName: String
  email: EmailAddressInput!
  customerGroupIdentifiers: [CustomerGroupIdentifier!]
  tenantIdentifiers: [TenantIdentifierInput!]
}

input UpsertCustomerOnUpdateInput {
  externalId: OptionalStringInput
  fullName: StringInput
  shortName: OptionalStringInput
  email: EmailAddressInput
}

input UpsertCustomerInput {
  identifier: UpsertCustomerIdentifierInput!
  onCreate: UpsertCustomerOnCreateInput!
  onUpdate: UpsertCustomerOnUpdateInput!
}

type UpsertCustomerOutput {
  result: UpsertResult
  customer: Customer
  error: MutationError
}

input CreateMachineUserInput {
  publicName: String!
  fullName: String!
  description: String

  """The type of machine user. Defaults to API_USER if not specified."""
  type: MachineUserType
  avatar: WorkspaceFileInput
}

type CreateMachineUserOutput {
  machineUser: MachineUser
  error: MutationError
}

input DeleteMachineUserInput {
  machineUserId: ID!
}

type DeleteMachineUserOutput {
  machineUser: MachineUser
  error: MutationError
}

input UpdateMachineUserInput {
  machineUserId: ID!
  fullName: StringInput
  publicName: StringInput
  description: StringInput

  """The type of machine user. Defaults to API_USER if not specified."""
  type: MachineUserType
  avatar: WorkspaceFileInput
}

type UpdateMachineUserOutput {
  machineUser: MachineUser
  error: MutationError
}

input CreateApiKeyInput {
  machineUserId: ID!
  description: String
  permissions: [String!]!
}

type CreateApiKeyOutput {
  apiKey: ApiKey
  apiKeySecret: String
  error: MutationError
}

input UpdateApiKeyInput {
  apiKeyId: ID!
  description: String
  permissions: [String!]!
}

type UpdateApiKeyOutput {
  apiKey: ApiKey
  error: MutationError
}

input DeleteApiKeyInput {
  apiKeyId: ID!
}

type DeleteApiKeyOutput {
  apiKey: ApiKey
  error: MutationError
}

input DeleteCustomerInput {
  customerId: ID!
}

type DeleteCustomerOutput {
  error: MutationError
}

input CreateCustomerEventInput {
  """The customer id of the customer that the event is for."""
  customerIdentifier: CustomerIdentifierInput!

  """
  The external ID of this event. You can use this field to store your own unique identifier for this event. This must be unique.
  """
  externalId: ID

  """The title of the event."""
  title: String!

  """The components used to create the event's contents."""
  components: [EventComponentInput!]!

  """
  When provided, this will override the timestamp of the event. Useful when backfilling events. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type CreateCustomerEventOutput {
  customerEvent: CustomerEvent
  error: MutationError
}

input CreateThreadEventInput {
  """The thread id of the thread that the event is for."""
  threadId: ID!

  """
  The external ID of this event. You can use this field to store your own unique identifier for this event. This must be unique.
  """
  externalId: ID

  """The title of the event."""
  title: String!

  """The components used to create the event's contents."""
  components: [EventComponentInput!]!

  """
  When provided, this will override the timestamp of the event. Useful when backfilling events. Must be in ISO 8601 format (e.g. 2024-10-28T18:30:00Z).
  """
  timestamp: String
}

type CreateThreadEventOutput {
  threadEvent: ThreadEvent
  error: MutationError
}

enum AutoresponderMessageSource {
  EMAIL
  API
  CHAT
  SLACK
  MS_TEAMS
  DISCORD
}

input AutoresponderConditionInput {
  tierId: ID
  isOutsideBusinessHours: Boolean
  supportEmailAddresses: [String!]
  labelTypeIds: [ID!]
  priorities: [Int!]
}

input CreateAutoresponderInput {
  name: String!
  order: Int!
  textContent: String!
  markdownContent: String
  isEnabled: Boolean!
  messageSources: [AutoresponderMessageSource!]!
  conditions: [AutoresponderConditionInput!]!
  responseDelaySeconds: Int
}

type CreateAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

input UpdateAutoresponderInput {
  autoresponderId: ID!
  name: StringInput
  order: IntInput
  textContent: StringInput
  markdownContent: OptionalStringInput
  isEnabled: BooleanInput
  messageSources: [AutoresponderMessageSource!]
  conditions: [AutoresponderConditionInput!]
  responseDelaySeconds: IntInput
}

type UpdateAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

input DeleteAutoresponderInput {
  autoresponderId: ID!
}

type DeleteAutoresponderOutput {
  autoresponder: Autoresponder
  error: MutationError
}

input AutoresponderOrderInput {
  autoresponderId: ID!
  order: Int!
}

input ReorderAutorespondersInput {
  autorespondersOrder: [AutoresponderOrderInput!]!
}

type ReorderAutorespondersOutput {
  autoresponders: [Autoresponder!]
  error: MutationError
}

type AutoresponderTierCondition {
  tierId: ID!
}

type AutoresponderBusinessHoursCondition {
  isOutsideBusinessHours: Boolean!
}

type AutoresponderSupportEmailsCondition {
  supportEmailAddresses: [String!]!
}

type AutoresponderLabelCondition {
  labelTypeIds: [ID!]!
}

type AutoresponderPrioritiesCondition {
  priorities: [Int!]!
}

union AutoresponderCondition = AutoresponderTierCondition | AutoresponderBusinessHoursCondition | AutoresponderSupportEmailsCondition | AutoresponderLabelCondition | AutoresponderPrioritiesCondition

type Autoresponder {
  id: ID!
  name: String!
  order: Int!
  messageSources: [AutoresponderMessageSource!]!
  conditions: [AutoresponderCondition!]!
  textContent: String!
  markdownContent: String
  isEnabled: Boolean!
  responseDelaySeconds: Int!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type AutoresponderConnection {
  edges: [AutoresponderEdge!]!
  pageInfo: PageInfo!
}

type AutoresponderEdge {
  cursor: String!
  node: Autoresponder!
}

type CsatCustomerSurveyTemplate {
  type: String!
  questionText: String!
}

union CustomerSurveyTemplate = CsatCustomerSurveyTemplate

type CustomerSurvey {
  id: ID!
  name: String!
  template: CustomerSurveyTemplate!
  conditions: [CustomerSurveyCondition!]!
  isEnabled: Boolean!
  responseDelayMinutes: Int!
  customerIntervalDays: Int!
  order: Int!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type CustomerSurveyTiersCondition {
  tierIds: [ID!]!
}

type CustomerSurveySupportEmailsCondition {
  supportEmailAddresses: [String!]!
}

type CustomerSurveyLabelCondition {
  labelTypeIds: [ID!]!
}

type CustomerSurveyPrioritiesCondition {
  priorities: [Int!]!
}

type CustomerSurveyMessageSourceCondition {
  messageSource: [MessageSource!]!
}

union CustomerSurveyCondition = CustomerSurveyTiersCondition | CustomerSurveySupportEmailsCondition | CustomerSurveyLabelCondition | CustomerSurveyPrioritiesCondition | CustomerSurveyMessageSourceCondition

input CustomerSurveyConditionInput {
  tierIds: [ID!]
  supportEmailAddresses: [String!]
  labelTypeIds: [ID!]
  priorities: [Int!]
  messageSource: [MessageSource!]
}

input CsatCustomerSurveyTemplateInput {
  type: String!
  questionText: String!
}

input CustomerSurveyTemplateInput {
  csatTemplate: CsatCustomerSurveyTemplateInput
}

input CreateCustomerSurveyInput {
  name: String!
  conditions: [CustomerSurveyConditionInput!]
  template: CustomerSurveyTemplateInput!
  isEnabled: Boolean!
  responseDelayMinutes: Int
  customerIntervalDays: Int
  order: Int
}

type CreateCustomerSurveyOutput {
  customerSurvey: CustomerSurvey
  error: MutationError
}

input UpdateCustomerSurveyInput {
  customerSurveyId: ID!
  name: StringInput
  conditions: [CustomerSurveyConditionInput!]
  template: CustomerSurveyTemplateInput
  order: Int
  isEnabled: BooleanInput
  responseDelayMinutes: IntInput
  customerIntervalDays: IntInput
}

type UpdateCustomerSurveyOutput {
  customerSurvey: CustomerSurvey
  error: MutationError
}

input DeleteCustomerSurveyInput {
  customerSurveyId: ID!
}

type DeleteCustomerSurveyOutput {
  error: MutationError
}

input CustomerSurveyOrderInput {
  customerSurveyId: ID!
  order: Int!
}

input ReorderCustomerSurveysInput {
  customerSurveyOrders: [CustomerSurveyOrderInput!]!
}

type ReorderCustomerSurveysOutput {
  customerSurveys: [CustomerSurvey!]
  error: MutationError
}

type Mutation {
  createUserAccount(input: CreateUserAccountInput!): CreateUserAccountOutput!
  changeUserStatus(input: ChangeUserStatusInput!): ChangeUserStatusOutput!
  updateMyUser(input: UpdateMyUserInput!): UpdateMyUserOutput!
  createWorkspace(input: CreateWorkspaceInput!): CreateWorkspaceOutput!
  updateWorkspace(input: UpdateWorkspaceInput!): UpdateWorkspaceOutput!
  inviteUserToWorkspace(input: InviteUserToWorkspaceInput!): InviteUserToWorkspaceOutput!
  acceptWorkspaceInvite(input: AcceptWorkspaceInviteInput!): AcceptWorkspaceInviteOutput!
  deleteWorkspaceInvite(input: DeleteWorkspaceInviteInput!): DeleteWorkspaceInviteOutput!
  deleteUser(input: DeleteUserInput!): DeleteUserOutput!
  assignRolesToUser(input: AssignRolesToUserInput!): AssignRolesToUserOutput!
  createLabelType(input: CreateLabelTypeInput!): CreateLabelTypeOutput!
  archiveLabelType(input: ArchiveLabelTypeInput!): ArchiveLabelTypeOutput!
  unarchiveLabelType(input: UnarchiveLabelTypeInput!): UnarchiveLabelTypeOutput!
  updateLabelType(input: UpdateLabelTypeInput!): UpdateLabelTypeOutput!
  moveLabelType(input: MoveLabelTypeInput!): MoveLabelTypeOutput!
  addLabels(input: AddLabelsInput!): AddLabelsOutput!
  addLabelsToUser(input: AddLabelsToUserInput!): AddLabelsToUserOutput!
  removeLabels(input: RemoveLabelsInput!): RemoveLabelsOutput!
  removeLabelsFromUser(input: RemoveLabelsFromUserInput!): RemoveLabelsFromUserOutput!
  createThreadLink(input: CreateThreadLinkInput!): CreateThreadLinkOutput!
  deleteThreadLink(input: DeleteThreadLinkInput!): DeleteThreadLinkOutput!
  createNote(input: CreateNoteInput!): CreateNoteOutput!
  deleteNote(input: DeleteNoteInput!): DeleteNoteOutput!
  createSavedThreadsView(input: CreateSavedThreadsViewInput!): CreateSavedThreadsViewOutput!
  updateSavedThreadsView(input: UpdateSavedThreadsViewInput!): UpdateSavedThreadsViewOutput!
  deleteSavedThreadsView(input: DeleteSavedThreadsViewInput!): DeleteSavedThreadsViewOutput!
  createMyFavoritePage(input: CreateMyFavoritePageInput!): CreateMyFavoritePageOutput!
  deleteMyFavoritePage(input: DeleteMyFavoritePageInput!): DeleteMyFavoritePageOutput!
  createSnippet(input: CreateSnippetInput!): CreateSnippetOutput!
  deleteSnippet(input: DeleteSnippetInput!): DeleteSnippetOutput!
  updateSnippet(input: UpdateSnippetInput!): UpdateSnippetOutput!

  """Creates or updates a customer."""
  upsertCustomer(input: UpsertCustomerInput!): UpsertCustomerOutput!

  """Changes the company of a customer."""
  updateCustomerCompany(input: UpdateCustomerCompanyInput!): UpdateCustomerCompanyOutput!

  """
  Deletes a customer and all of their data stored on Plain. This action cannot be reversed.
  """
  deleteCustomer(input: DeleteCustomerInput!): DeleteCustomerOutput!

  """Marks a customer as spam."""
  markCustomerAsSpam(input: MarkCustomerAsSpamInput!): MarkCustomerAsSpamOutput!

  """Removes the spam mark from a customer."""
  unmarkCustomerAsSpam(input: UnmarkCustomerAsSpamInput!): UnmarkCustomerAsSpamOutput!

  """Creates or updates a customer group."""
  upsertCustomerGroup(input: UpsertCustomerGroupInput!): UpsertCustomerGroupOutput!

  """Create a new customer group."""
  createCustomerGroup(input: CreateCustomerGroupInput!): CreateCustomerGroupOutput!

  """Update a customer group."""
  updateCustomerGroup(input: UpdateCustomerGroupInput!): UpdateCustomerGroupOutput!

  """Delete a customer group by ID."""
  deleteCustomerGroup(input: DeleteCustomerGroupInput!): DeleteCustomerGroupOutput!

  """Add a customer to a customer group."""
  addCustomerToCustomerGroups(input: AddCustomerToCustomerGroupsInput!): AddCustomerToCustomerGroupsOutput!

  """Remove a customer from a customer group."""
  removeCustomerFromCustomerGroups(input: RemoveCustomerFromCustomerGroupsInput!): RemoveCustomerFromCustomerGroupsOutput!
  createThreadFieldSchema(input: CreateThreadFieldSchemaInput!): CreateThreadFieldSchemaOutput!
  updateThreadFieldSchema(input: UpdateThreadFieldSchemaInput!): UpdateThreadFieldSchemaOutput!
  deleteThreadFieldSchema(input: DeleteThreadFieldSchemaInput!): DeleteThreadFieldSchemaOutput!
  reorderThreadFieldSchemas(input: ReorderThreadFieldSchemasInput!): ReorderThreadFieldSchemasOutput!
  upsertThreadField(input: UpsertThreadFieldInput!): UpsertThreadFieldOutput!
  bulkUpsertThreadFields(input: BulkUpsertThreadFieldsInput!): BulkUpsertThreadFieldsOutput!
  deleteThreadField(input: DeleteThreadFieldInput!): DeleteThreadFieldOutput!
  createEscalationPath(input: CreateEscalationPathInput!): CreateEscalationPathOutput!
  updateEscalationPath(input: UpdateEscalationPathInput!): UpdateEscalationPathOutput!
  deleteEscalationPath(input: DeleteEscalationPathInput!): DeleteEscalationPathOutput!
  createWorkflowRule(input: CreateWorkflowRuleInput!): CreateWorkflowRuleOutput!
  updateWorkflowRule(input: UpdateWorkflowRuleInput!): UpdateWorkflowRuleOutput!
  toggleWorkflowRulePublished(input: ToggleWorkflowRulePublishedInput!): ToggleWorkflowRulePublishedOutput!
  deleteWorkflowRule(input: DeleteWorkflowRuleInput!): DeleteWorkflowRuleOutput!
  sendChat(input: SendChatInput!): SendChatOutput!
  sendCustomerChat(input: SendCustomerChatInput!): SendCustomerChatOutput!
  createChatApp(input: CreateChatAppInput!): CreateChatAppOutput!
  updateChatApp(input: UpdateChatAppInput!): UpdateChatAppOutput!
  deleteChatApp(input: DeleteChatAppInput!): DeleteChatAppOutput!
  createChatAppSecret(input: CreateChatAppSecretInput!): CreateChatAppSecretOutput!
  deleteChatAppSecret(input: DeleteChatAppSecretInput!): DeleteChatAppSecretOutput!
  sendMSTeamsMessage(input: SendMSTeamsMessageInput!): SendMSTeamsMessageOutput!
  sendSlackMessage(input: SendSlackMessageInput!): SendSlackMessageOutput!
  shareThreadToUserInSlack(input: ShareThreadToUserInSlackInput!): ShareThreadToUserInSlackOutput!
  sendDiscordMessage(input: SendDiscordMessageInput!): SendDiscordMessageOutput!

  """Adds or removes a reaction from a slack message timeline entry."""
  toggleSlackMessageReaction(input: ToggleSlackMessageReactionInput!): ToggleSlackMessageReactionOutput!
  forkThread(input: ForkThreadInput!): ForkThreadOutput!
  updateConnectedSlackChannel(input: UpdateConnectedSlackChannelInput!): UpdateConnectedSlackChannelOutput!
  bulkJoinSlackChannels(input: BulkJoinSlackChannelsInput!): BulkJoinSlackChannelsOutput!

  """Create a new customer event."""
  createCustomerEvent(input: CreateCustomerEventInput!): CreateCustomerEventOutput!

  """Create a new thread event."""
  createThreadEvent(input: CreateThreadEventInput!): CreateThreadEventOutput!
  createWorkspaceEmailDomainSettings(input: CreateWorkspaceEmailDomainSettingsInput!): CreateWorkspaceEmailDomainSettingsOutput!
  deleteWorkspaceEmailDomainSettings: DeleteWorkspaceEmailDomainSettingsOutput!
  verifyWorkspaceEmailForwardingSettings(input: VerifyWorkspaceEmailForwardingSettingsInput!): VerifyWorkspaceEmailForwardingSettingsOutput!
  verifyWorkspaceEmailDnsSettings: VerifyWorkspaceEmailDnsSettingsOutput!
  updateWorkspaceEmailSettings(input: UpdateWorkspaceEmailSettingsInput!): UpdateWorkspaceEmailSettingsOutput!
  addWorkspaceAlternateSupportEmailAddress(input: AddWorkspaceAlternateSupportEmailAddressInput!): AddWorkspaceAlternateSupportEmailAddressOutput!
  removeWorkspaceAlternateSupportEmailAddress(input: RemoveWorkspaceAlternateSupportEmailAddressInput!): RemoveWorkspaceAlternateSupportEmailAddressOutput!
  sendNewEmail(input: SendNewEmailInput!): SendNewEmailOutput!
  replyToEmail(input: ReplyToEmailInput!): ReplyToEmailOutput!
  createEmailPreviewUrl(input: CreateEmailPreviewUrlInput!): CreateEmailPreviewUrlOutput!
  sendBulkEmail(input: SendBulkEmailInput!): SendBulkEmailOutput!
  createAttachmentDownloadUrl(input: CreateAttachmentDownloadUrlInput!): CreateAttachmentDownloadUrlOutput!
  createAttachmentUploadUrl(input: CreateAttachmentUploadUrlInput!): CreateAttachmentUploadUrlOutput!
  createMachineUser(input: CreateMachineUserInput!): CreateMachineUserOutput!
  deleteMachineUser(input: DeleteMachineUserInput!): DeleteMachineUserOutput!
  updateMachineUser(input: UpdateMachineUserInput!): UpdateMachineUserOutput!
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyOutput!
  updateApiKey(input: UpdateApiKeyInput!): UpdateApiKeyOutput!
  deleteApiKey(input: DeleteApiKeyInput!): DeleteApiKeyOutput!
  createMySlackIntegration(input: CreateMySlackIntegrationInput!): CreateMySlackIntegrationOutput!
  deleteMySlackIntegration: DeleteMySlackIntegrationOutput!
  createUserAuthSlackIntegration(input: CreateUserAuthSlackIntegrationInput!): CreateUserAuthSlackIntegrationOutput!
  deleteUserAuthSlackIntegration(input: DeleteUserAuthSlackIntegrationInput!): DeleteUserAuthSlackIntegrationOutput!
  createWorkspaceSlackIntegration(input: CreateWorkspaceSlackIntegrationInput!): CreateWorkspaceSlackIntegrationOutput!
  deleteWorkspaceSlackIntegration(input: DeleteWorkspaceSlackIntegrationInput!): DeleteWorkspaceSlackIntegrationOutput!
  createWorkspaceSlackChannelIntegration(input: CreateWorkspaceSlackChannelIntegrationInput!): CreateWorkspaceSlackChannelIntegrationOutput!
  refreshWorkspaceSlackChannelIntegration(input: RefreshWorkspaceSlackChannelIntegrationInput!): RefreshWorkspaceSlackChannelIntegrationOutput!
  deleteWorkspaceSlackChannelIntegration(input: DeleteWorkspaceSlackChannelIntegrationInput!): DeleteWorkspaceSlackChannelIntegrationOutput!
  createWorkspaceDiscordChannelIntegration(input: CreateWorkspaceDiscordChannelIntegrationInput!): CreateWorkspaceDiscordChannelIntegrationOutput!
  deleteWorkspaceDiscordChannelIntegration(input: DeleteWorkspaceDiscordChannelIntegrationInput!): DeleteWorkspaceDiscordChannelIntegrationOutput!
  createUserAuthDiscordChannelIntegration(input: CreateUserAuthDiscordChannelIntegrationInput!): CreateUserAuthDiscordChannelIntegrationOutput!
  deleteUserAuthDiscordChannelIntegration(input: DeleteUserAuthDiscordChannelIntegrationInput!): DeleteUserAuthDiscordChannelIntegrationOutput!
  refreshConnectedDiscordChannels(input: RefreshConnectedDiscordChannelsInput!): RefreshConnectedDiscordChannelsOutput!
  updateConnectedDiscordChannel(input: UpdateConnectedDiscordChannelInput!): UpdateConnectedDiscordChannelOutput!
  createWorkspaceDiscordIntegration(input: CreateWorkspaceDiscordIntegrationInput!): CreateWorkspaceDiscordIntegrationOutput!
  deleteWorkspaceDiscordIntegration(input: DeleteWorkspaceDiscordIntegrationInput!): DeleteWorkspaceDiscordIntegrationOutput!
  createMyLinearIntegration(input: CreateMyLinearIntegrationInput!): CreateMyLinearIntegrationOutput!
  deleteMyLinearIntegration: DeleteMyLinearIntegrationOutput!
  createMyMSTeamsIntegration(input: CreateMyMSTeamsIntegrationInput!): CreateMyMSTeamsIntegrationOutput!
  deleteMyMSTeamsIntegration: DeleteMyMSTeamsIntegrationOutput!
  createWorkspaceMSTeamsIntegration(input: CreateWorkspaceMSTeamsIntegrationInput!): CreateWorkspaceMSTeamsIntegrationOutput!
  deleteWorkspaceMSTeamsIntegration(input: DeleteWorkspaceMSTeamsIntegrationInput!): DeleteWorkspaceMSTeamsIntegrationOutput!

  """Updates a setting."""
  updateSetting(input: UpdateSettingInput!): UpdateSettingOutput!

  """
  Creates a customer card config. A maximum of 25 card configs can be created.
  """
  createCustomerCardConfig(input: CreateCustomerCardConfigInput!): CreateCustomerCardConfigOutput!

  """Partially updates a customer card config."""
  updateCustomerCardConfig(input: UpdateCustomerCardConfigInput!): UpdateCustomerCardConfigOutput!

  """Deletes a customer card config."""
  deleteCustomerCardConfig(input: DeleteCustomerCardConfigInput!): DeleteCustomerCardConfigOutput!

  """
  Reorders customer card configs.
  
  The input can be a partial input and in that case not all configs will be reordered.
  For example this allows two configs to be swapped with each other.
  
  Note: Duplicate orders are allowed by the API.
  """
  reorderCustomerCardConfigs(input: ReorderCustomerCardConfigsInput!): ReorderCustomerCardConfigsOutput!

  """
  Reloads a customer card for a customer.
  
  Will discard whatever is in the cache and reload it from the configured API URL.
  """
  reloadCustomerCardInstance(input: ReloadCustomerCardInstanceInput!): ReloadCustomerCardInstanceOutput!

  """Creates a webhook target."""
  createWebhookTarget(input: CreateWebhookTargetInput!): CreateWebhookTargetOutput!

  """Updates a webhook target."""
  updateWebhookTarget(input: UpdateWebhookTargetInput!): UpdateWebhookTargetOutput!

  """Deletes a webhook target."""
  deleteWebhookTarget(input: DeleteWebhookTargetInput!): DeleteWebhookTargetOutput!
  createThread(input: CreateThreadInput!): CreateThreadOutput!
  assignThread(input: AssignThreadInput!): AssignThreadOutput!
  unassignThread(input: UnassignThreadInput!): UnassignThreadOutput!
  addAdditionalAssignees(input: AddAdditionalAssigneesInput!): AddAdditionalAssigneesOutput!
  removeAdditionalAssignees(input: RemoveAdditionalAssigneesInput!): RemoveAdditionalAssigneesOutput!
  snoozeThread(input: SnoozeThreadInput!): SnoozeThreadOutput!
  markThreadAsDone(input: MarkThreadAsDoneInput!): MarkThreadAsDoneOutput!
  markThreadAsTodo(input: MarkThreadAsTodoInput!): MarkThreadAsTodoOutput!
  changeThreadCustomer(input: ChangeThreadCustomerInput!): ChangeThreadCustomerOutput!
  changeThreadPriority(input: ChangeThreadPriorityInput!): ChangeThreadPriorityOutput!
  updateThreadTitle(input: UpdateThreadTitleInput!): UpdateThreadTitleOutput!
  updateThreadTenant(input: UpdateThreadTenantInput!): UpdateThreadTenantOutput!
  updateThreadTier(input: UpdateThreadTierInput!): UpdateThreadTierOutput!
  updateThreadEscalationPath(input: UpdateThreadEscalationPathInput!): UpdateThreadEscalationPathOutput!
  createThreadDiscussion(input: CreateThreadDiscussionInput!): CreateThreadDiscussionOutput!
  sendThreadDiscussionMessage(input: SendThreadDiscussionMessageInput!): SendThreadDiscussionMessageOutput!
  markThreadDiscussionAsResolved(input: MarkThreadDiscussionAsResolvedInput!): MarkThreadDiscussionAsResolvedOutput!

  """
  Reply to the last message in a thread. This mutation supports replying to threads where the last message is
  a Slack message, an email or a form submission. If the thread is empty, it will send an email to the customer.
  """
  replyToThread(input: ReplyToThreadInput!): ReplyToThreadOutput!
  upsertMyEmailSignature(input: UpsertMyEmailSignatureInput!): UpsertMyEmailSignatureOutput!
  createAutoresponder(input: CreateAutoresponderInput!): CreateAutoresponderOutput!
  updateAutoresponder(input: UpdateAutoresponderInput!): UpdateAutoresponderOutput!
  deleteAutoresponder(input: DeleteAutoresponderInput!): DeleteAutoresponderOutput!
  reorderAutoresponders(input: ReorderAutorespondersInput!): ReorderAutorespondersOutput!
  upsertTenant(input: UpsertTenantInput!): UpsertTenantOutput!
  addCustomerToTenants(input: AddCustomerToTenantsInput!): AddCustomerToTenantsOutput!
  removeCustomerFromTenants(input: RemoveCustomerFromTenantsInput!): RemoveCustomerFromTenantsOutput!
  setCustomerTenants(input: SetCustomerTenantsInput!): SetCustomerTenantsOutput!
  upsertCompany(input: UpsertCompanyInput!): UpsertCompanyOutput!
  deleteCompany(input: DeleteCompanyInput!): DeleteCompanyOutput!
  startServiceAuthorization(input: StartServiceAuthorizationInput!): StartServiceAuthorizationOutput!
  completeServiceAuthorization(input: CompleteServiceAuthorizationInput!): CompleteServiceAuthorizationOutput!

  """Delete the workspace service authorization."""
  deleteServiceAuthorization(input: DeleteServiceAuthorizationInput!): DeleteServiceAuthorizationOutput!

  """Delete personal service authorizations for the current user."""
  deleteMyServiceAuthorization(input: DeleteMyServiceAuthorizationInput!): DeleteMyServiceAuthorizationOutput!
  createTier(input: CreateTierInput!): CreateTierOutput!
  updateTier(input: UpdateTierInput!): UpdateTierOutput!
  deleteTier(input: DeleteTierInput!): DeleteTierOutput!
  createServiceLevelAgreement(input: CreateServiceLevelAgreementInput!): CreateServiceLevelAgreementOutput!
  updateServiceLevelAgreement(input: UpdateServiceLevelAgreementInput!): UpdateServiceLevelAgreementOutput!
  deleteServiceLevelAgreement(input: DeleteServiceLevelAgreementInput!): DeleteServiceLevelAgreementOutput!
  addMembersToTier(input: AddMembersToTierInput!): AddMembersToTierOutput!
  removeMembersFromTier(input: RemoveMembersFromTierInput!): RemoveMembersFromTierOutput!
  updateCompanyTier(input: UpdateCompanyTierInput!): UpdateCompanyTierOutput!
  updateTenantTier(input: UpdateTenantTierInput!): UpdateTenantTierOutput!
  upsertBusinessHours(input: UpsertBusinessHoursInput!): UpsertBusinessHoursOutput! @deprecated(reason: "Use syncBusinessHoursSlots instead.")
  deleteBusinessHours: DeleteBusinessHoursOutput! @deprecated(reason: "Use syncBusinessHoursSlots instead.")
  syncBusinessHoursSlots(input: SyncBusinessHoursSlotsInput!): SyncBusinessHoursSlotsOutput!
  createCheckoutSession(input: CreateCheckoutSessionInput!): CreateCheckoutSessionOutput!
  createBillingPortalSession: CreateBillingPortalSessionOutput!
  calculateRoleChangeCost(input: CalculateRoleChangeCostInput!): CalculateRoleChangeCostOutput!
  addUserToActiveBillingRota(input: AddUserToActiveBillingRotaInput!): AddUserToActiveBillingRotaOutput!
  removeUserFromActiveBillingRota(input: RemoveUserFromActiveBillingRotaInput!): RemoveUserFromActiveBillingRotaOutput!
  updateActiveBillingRota(input: UpdateActiveBillingRotaInput!): UpdateActiveBillingRotaOutput!
  changeBillingPlan(input: ChangeBillingPlanInput!): ChangeBillingPlanOutput!
  previewBillingPlanChange(input: PreviewBillingPlanChangeInput!): PreviewBillingPlanChangeOutput!
  regenerateWorkspaceHmac: RegenerateWorkspaceHmacOutput!
  createIndexedDocument(input: CreateIndexedDocumentInput!): CreateIndexedDocumentOutput!
  deleteIndexedDocument(input: DeleteIndexedDocumentInput!): DeleteIndexedDocumentOutput!
  updateGeneratedReply(input: UpdateGeneratedReplyInput!): UpdateGeneratedReplyOutput!
  createKnowledgeSource(input: CreateKnowledgeSourceInput!): CreateKnowledgeSourceOutput!
  createThreadChannelAssociation(input: CreateThreadChannelAssociationInput!): CreateThreadChannelAssociationOutput!
  deleteThreadChannelAssociation(input: DeleteThreadChannelAssociationInput!): DeleteThreadChannelAssociationOutput!
  createWorkspaceFileUploadUrl(input: CreateWorkspaceFileUploadUrlInput!): CreateWorkspaceFileUploadUrlOutput!
  deleteWorkspaceFile(input: DeleteWorkspaceFileInput!): DeleteWorkspaceFileOutput!

  """
  Resolves a customer for a Slack channel by finding or creating a customer associated with one of the Slack users in the channel.
  """
  resolveCustomerForSlackChannel(input: ResolveCustomerForSlackChannelInput!): ResolveCustomerForSlackChannelOutput!
  createHelpCenter(input: CreateHelpCenterInput!): CreateHelpCenterOutput!
  updateHelpCenter(input: UpdateHelpCenterInput!): UpdateHelpCenterOutput!
  deleteHelpCenter(input: DeleteHelpCenterInput!): DeleteHelpCenterOutput!
  updateHelpCenterCustomDomainName(input: UpdateHelpCenterCustomDomainNameInput!): UpdateHelpCenterCustomDomainNameOutput!
  verifyHelpCenterCustomDomainName(input: VerifyHelpCenterCustomDomainNameInput!): VerifyHelpCenterCustomDomainNameOutput!
  updateHelpCenterIndex(input: UpdateHelpCenterIndexInput!): UpdateHelpCenterIndexOutput!
  upsertHelpCenterArticle(input: UpsertHelpCenterArticleInput!): UpsertHelpCenterArticleOutput!
  deleteHelpCenterArticle(input: DeleteHelpCenterArticleInput!): DeleteHelpCenterArticleOutput!
  generateHelpCenterArticle(input: GenerateHelpCenterArticleInput!): GenerateHelpCenterArticleOutput!
  createHelpCenterArticleGroup(input: CreateHelpCenterArticleGroupInput!): CreateHelpCenterArticleGroupOutput!
  updateHelpCenterArticleGroup(input: UpdateHelpCenterArticleGroupInput!): UpdateHelpCenterArticleGroupOutput!
  deleteHelpCenterArticleGroup(input: DeleteHelpCenterArticleGroupInput!): DeleteHelpCenterArticleGroupOutput!
  createIssueTrackerIssue(input: CreateIssueTrackerIssueInput!): CreateIssueTrackerIssueOutput!
  createCustomerSurvey(input: CreateCustomerSurveyInput!): CreateCustomerSurveyOutput!
  updateCustomerSurvey(input: UpdateCustomerSurveyInput!): UpdateCustomerSurveyOutput!
  deleteCustomerSurvey(input: DeleteCustomerSurveyInput!): DeleteCustomerSurveyOutput!
  reorderCustomerSurveys(input: ReorderCustomerSurveysInput!): ReorderCustomerSurveysOutput!
  addGeneratedReply(input: AddGeneratedReplyInput!): AddGeneratedReplyOutput!
  escalateThread(input: EscalateThreadInput!): EscalateThreadOutput!
}

input EscalateThreadInput {
  threadId: ID!
}

type EscalateThreadOutput {
  thread: Thread
  error: MutationError
}

input MoveLabelTypeInput {
  labelTypeId: ID!

  """
  Move the label type immediately after the label type with the given ID. Required if beforeLabelTypeId is not provided.
  """
  afterLabelTypeId: ID

  """
  Move the label type immediately before the label type with the given ID. Required if afterLabelTypeId is not provided.
  """
  beforeLabelTypeId: ID

  """
  Move the label type to be a child of the specified parent. When provided alone, the label will be moved to the end of the parent's children. When provided with afterLabelTypeId or beforeLabelTypeId, validates that the reference label has the same parent.
  """
  parentLabelTypeId: ID
}

type MoveLabelTypeOutput {
  labelType: LabelType
  error: MutationError
}

input GenerateHelpCenterArticleInput {
  threadId: ID!
  helpCenterId: ID!
}

type GenerateHelpCenterArticleOutput {
  helpCenterArticles: [HelpCenterArticle!]!
  error: MutationError
}

type DeleteCompanyOutput {
  company: Company
  error: MutationError
}

input DeleteCompanyInput {
  companyIdentifier: CompanyIdentifierInput!
}

input HelpCenterIndexItemInput {
  type: HelpCenterIndexItemType!
  entityId: ID!
  parentId: ID
}

input UpdateHelpCenterIndexInput {
  helpCenterId: ID!
  hash: String!
  helpCenterIndex: [HelpCenterIndexItemInput!]!
}

type UpdateHelpCenterIndexOutput {
  helpCenterIndex: HelpCenterIndex
  error: MutationError
}

input UpdateHelpCenterCustomDomainNameInput {
  helpCenterId: ID!
  customDomainName: OptionalStringInput!
}

input VerifyHelpCenterCustomDomainNameInput {
  helpCenterId: ID!
}

type UpdateHelpCenterCustomDomainNameOutput {
  helpCenter: HelpCenter
  error: MutationError
}

type VerifyHelpCenterCustomDomainNameOutput {
  helpCenter: HelpCenter
  error: MutationError
}

enum GeneratedReplyFeedbackType {
  POSITIVE
  NEGATIVE
  UNKNOWN
}

input OptionalGeneratedReplyFeedbackInput {
  value: GeneratedReplyFeedbackType
}

input AddGeneratedReplyInput {
  threadId: ID!
  timelineEntryId: ID!
  markdown: String!
}

type AddGeneratedReplyOutput {
  generatedReply: GeneratedReply
  error: MutationError
}

input GeneratedReplyFeedbackInput {
  type: OptionalGeneratedReplyFeedbackInput
}

input UpdateGeneratedReplyInput {
  generatedReplyId: ID!
  feedback: GeneratedReplyFeedbackInput
}

type UpdateGeneratedReplyOutput {
  generatedReply: GeneratedReply
  error: MutationError
}

input CreateIndexedDocumentInput {
  url: String!
  labelTypeIds: [ID!]
  knowledgeSourceId: ID
}

type CreateIndexedDocumentOutput {
  error: MutationError
  indexedDocument: IndexedDocument
}

input DeleteIndexedDocumentInput {
  indexedDocumentId: ID!
}

type DeleteIndexedDocumentOutput {
  error: MutationError
}

type IndexedDocument {
  id: ID!
  url: String!
  labelTypes: [LabelType!]!
  status: IndexedDocumentStatus!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union IndexedDocumentStatus = IndexedDocumentStatusIndexed | IndexedDocumentStatusPending | IndexedDocumentStatusFailed

type IndexedDocumentStatusIndexed {
  indexedAt: DateTime!
}

type IndexedDocumentStatusPending {
  startedAt: DateTime!
}

type IndexedDocumentStatusFailed {
  reason: String!
  failedAt: DateTime!
}

type IndexedDocumentConnection {
  edges: [IndexedDocumentEdge!]!
  pageInfo: PageInfo!
}

type IndexedDocumentEdge {
  cursor: String!
  node: IndexedDocument!
}

input IndexedDocumentsFilter {
  knowledgeSourceId: ID
}

input CreateKnowledgeSourceInput {
  url: String!
  labelTypeIds: [ID!]
  type: KnowledgeSourceType!
}

enum KnowledgeSourceType {
  SITEMAP
  URL
}

type CreateKnowledgeSourceOutput {
  knowledgeSource: KnowledgeSource
  error: MutationError
}

input KnowledgeSourcesFilter {
  type: KnowledgeSourceType
}

type KnowledgeSourceConnection {
  edges: [KnowledgeSourceEdge!]!
  pageInfo: PageInfo!
}

type KnowledgeSourceEdge {
  cursor: String!
  node: KnowledgeSource!
}

union KnowledgeSource = KnowledgeSourceSitemap | KnowledgeSourceUrl

type KnowledgeSourceSitemap {
  id: ID!
  type: KnowledgeSourceType!
  url: String!
  labelTypes: [LabelType!]!
  status: IndexingStatus!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type KnowledgeSourceUrl {
  id: ID!
  type: KnowledgeSourceType!
  url: String!
  labelTypes: [LabelType!]!
  status: IndexingStatus!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

union IndexingStatus = IndexingStatusPending | IndexingStatusIndexed | IndexingStatusFailed

type IndexingStatusPending {
  startedAt: DateTime!
}

type IndexingStatusIndexed {
  indexedAt: DateTime!
}

type IndexingStatusFailed {
  reason: String!
  failedAt: DateTime!
}

input CreateThreadDiscussionInput {
  threadId: ID!
  connectedSlackChannelId: ID!
  markdownContent: String!
}

type CreateThreadDiscussionOutput {
  threadDiscussion: ThreadDiscussion
  error: MutationError
}

input SendThreadDiscussionMessageInput {
  threadDiscussionId: ID!
  markdownContent: String!
  attachmentIds: [ID!]
}

type SendThreadDiscussionMessageOutput {
  threadDiscussionMessage: ThreadDiscussionMessage
  error: MutationError
}

input MarkThreadDiscussionAsResolvedInput {
  threadDiscussionId: ID!
}

type MarkThreadDiscussionAsResolvedOutput {
  error: MutationError
}

input UpdateCompanyTierInput {
  tierIdentifier: TierIdentifierInput
  companyIdentifier: CompanyIdentifierInput!
}

type UpdateCompanyTierOutput {
  companyTierMembership: CompanyTierMembership
  error: MutationError
}

input ChangeThreadCustomerInput {
  threadId: ID!
  customerId: ID!
}

type ChangeThreadCustomerOutput {
  thread: Thread
  error: MutationError
}

input UpdateTenantTierInput {
  tierIdentifier: TierIdentifierInput
  tenantIdentifier: TenantIdentifierInput!
}

type UpdateTenantTierOutput {
  tenantTierMembership: TenantTierMembership
  error: MutationError
}

input AddMembersToTierInput {
  tierIdentifier: TierIdentifierInput!
  memberIdentifiers: [TierMemberIdentifierInput!]!
}

type AddMembersToTierOutput {
  memberships: [TierMembership!]!
  error: MutationError
}

input RemoveMembersFromTierInput {
  memberIdentifiers: [TierMemberIdentifierInput!]!
}

type RemoveMembersFromTierOutput {
  memberships: [TierMembership!]!
  error: MutationError
}

input CreateTierInput {
  """The name of this tier."""
  name: String!

  """
  The external ID of this tier. You can use this field to store your own unique identifier for this tier. This must be unique in your workspace.
  """
  externalId: String!

  """
  The color to assign to this tier, given by its hex code (e.g. #FABADA). This color is used in Plain's UI to represent this tier.
  """
  color: String!

  """
  Any thread created in this tier will have this priority by default, unless a different priority is specified while creating it. If not provided, it defaults to 2 (normal priority).
  """
  defaultThreadPriority: Int
  memberIdentifiers: [TierMemberIdentifierInput!]!

  """
  If set to true, this tier will be applied to all threads that do not match any other tier.
  
  Only one tier can be the default tier.
  
  Default: false
  """
  isDefault: Boolean
}

input ServiceLevelAgreementThreadLabelTypeIdFilterInput {
  """
  The label type IDs that the thread needs to have in order for the SLA to be applied. Based on the 'requireAll' field.
  """
  labelTypeIds: [ID!]!

  """
  If true, the SLA will only be applied to threads that have all of the provided label types. If false, the SLA will be applied to threads that have any of the provided label types.
  """
  requireAll: Boolean!
}

input ServiceLevelAgreementInput {
  """Set this to configure the firt response time SLA."""
  firstResponseTimeMinutes: Int

  """Set this to configure an SLA for next responses."""
  nextResponseTimeMinutes: Int

  """
  This SLA can only be applied to a thread if it has one of these priority values. If not provided, it defaults to all priorities (0, 1, 2 and 3).
  """
  threadPriorityFilter: [Int!]

  """
  This SLA can only be applied to a thread if it has one or all of these label types. If not provided, the filter is not applied.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilterInput

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: Boolean!

  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachActionInput!]!
}

input BreachActionInput {
  beforeBreachAction: BeforeBreachActionInput
}

input BeforeBreachActionInput {
  beforeBreachMinutes: Int!
}

input TierMemberIdentifierInput {
  companyId: ID
  tenantId: ID
}

type CreateTierOutput {
  tier: Tier
  error: MutationError
}

input UpdateTierInput {
  tierId: ID!
  name: StringInput
  externalId: OptionalStringInput
  color: StringInput
  defaultThreadPriority: IntInput
  isDefault: BooleanInput
}

type UpdateTierOutput {
  tier: Tier
  error: MutationError
}

input DeleteTierInput {
  tierId: ID!
}

type DeleteTierOutput {
  tier: Tier
  error: MutationError
}

input CreateServiceLevelAgreementInput {
  tierId: ID!
  serviceLevelAgreement: ServiceLevelAgreementInput!
}

type CreateServiceLevelAgreementOutput {
  serviceLevelAgreement: ServiceLevelAgreement
  error: MutationError
}

input IntArrayInput {
  value: [Int!]!
}

input UpdateServiceLevelAgreementInput {
  """The ID of the SLA to update."""
  serviceLevelAgreementId: ID!

  """
  This SLA will breach if it does not receive a first response within this many minutes. May only be provided if the service level agreement is a first response time SLA.
  """
  firstResponseTimeMinutes: IntInput

  """
  This SLA will breach if it does not receive a next response within this many minutes. May only be provided if the service level agreement is a next response time SLA.
  """
  nextResponseTimeMinutes: IntInput

  """
  This SLA can only be applied to a thread if it has one of these priority values. If not provided, it defaults to all priorities (0, 1, 2 and 3).
  """
  threadPriorityFilter: IntArrayInput

  """
  This SLA can only be applied to a thread if it has one or all of these label types. If not provided, the filter is not applied.
  """
  threadLabelTypeIdFilter: ServiceLevelAgreementThreadLabelTypeIdFilterInput

  """
  If true, the SLA will only be tracked during your workspace's business hours. If false, the SLA will tracked 24/7.
  """
  useBusinessHoursOnly: BooleanInput

  """
  The actions to take when the SLA is about to breach and when it breaches.
  """
  breachActions: [BreachActionInput!]
}

type UpdateServiceLevelAgreementOutput {
  serviceLevelAgreement: ServiceLevelAgreement
  error: MutationError
}

input DeleteServiceLevelAgreementInput {
  serviceLevelAgreementId: ID!
}

type DeleteServiceLevelAgreementOutput {
  serviceLevelAgreement: ServiceLevelAgreement
  error: MutationError
}

input UpsertCompanyInput {
  identifier: CompanyIdentifierInput!
  name: String!
  domainName: String!
  contractValue: Int
  accountOwnerUserId: ID
}

type UpsertCompanyOutput {
  company: Company
  result: UpsertResult
  error: MutationError
}

type Tenant {
  id: ID!
  name: String!
  externalId: String!
  url: String
  tier: Tier
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input TenantIdentifierInput {
  tenantId: ID
  externalId: String
}

input UpsertTenantInput {
  identifier: TenantIdentifierInput!
  name: String!
  externalId: String!
  url: OptionalStringInput
}

type UpsertTenantOutput {
  tenant: Tenant
  result: UpsertResult
  error: MutationError
}

input CompanyIdentifierInput {
  """Plain's internal identifier for the company."""
  companyId: ID

  """
  The domain name of the company (e.g. plain.com). Alternatively, you can provide a full URL (e.g. https://www.plain.com) and we will do our best to extract the domain name.
  """
  companyDomainName: String
}

input UpdateCustomerCompanyInput {
  """The identifier of the customer we want to update the company for."""
  customerId: ID!

  """
  The identifier of the company we want to update the customer with. Pass null if you want to remove the company from the customer.
  """
  companyIdentifier: CompanyIdentifierInput
}

type UpdateCustomerCompanyOutput {
  customer: Customer
  error: MutationError
}

input SendMSTeamsMessageInput {
  threadId: ID!
  markdownContent: String
  attachmentIds: [ID!]
}

type SendMSTeamsMessageOutput {
  msTeamsMessage: MSTeamsMessage
  error: MutationError
}

input SendSlackMessageInput {
  threadId: ID!
  textContent: String @deprecated(reason: "Use markdownContent instead")
  markdownContent: String
  attachmentIds: [ID!]
  unfurlLinks: Boolean
}

type SendSlackMessageOutput {
  error: MutationError
}

input ShareThreadToUserInSlackInput {
  threadId: ID!
  userId: ID!
}

type ShareThreadToUserInSlackOutput {
  error: MutationError
}

input SendDiscordMessageInput {
  threadId: ID!
  markdownContent: String
  attachmentIds: [ID!]
}

type SendDiscordMessageOutput {
  discordMessage: DiscordMessage
  error: MutationError
}

input ToggleSlackMessageReactionInput {
  threadId: ID!
  timelineEntryId: ID!
  reactionName: String!
}

type ToggleSlackMessageReactionOutput {
  error: MutationError
}

input ForkThreadInput {
  threadId: ID!
  timelineEntryId: ID!
}

type ForkThreadOutput {
  thread: Thread
  error: MutationError
}

input CustomerImpersonationInput {
  customerIdentifier: CustomerIdentifierInput!
}

input ImpersonationInput {
  asCustomer: CustomerImpersonationInput!
}

input ReplyToThreadEmailChannelSpecificOptionsInput {
  additionalRecipients: [EmailParticipantInput!]
  hiddenRecipients: [EmailParticipantInput!]
}

input ReplyToThreadChannelSpecificOptionsInput {
  email: ReplyToThreadEmailChannelSpecificOptionsInput!
}

input ReplyToThreadInput {
  threadId: ID!
  textContent: String!
  markdownContent: String
  impersonation: ImpersonationInput
  attachmentIds: [ID!]
  channelSpecificOptions: ReplyToThreadChannelSpecificOptionsInput
}

type ReplyToThreadOutput {
  error: MutationError
}

"""
Query to search for threads. The search term provided is used to match against different parts of the thread:
- its title
- its messages
- the customer's name
- the customer's email
"""
input ThreadsSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive.
  """
  term: String!
}

type ThreadSearchResult {
  thread: Thread!
}

type ThreadSearchResultEdge {
  cursor: String!
  node: ThreadSearchResult!
}

type ThreadSearchResultConnection {
  edges: [ThreadSearchResultEdge!]!
  pageInfo: PageInfo!
}

input UpsertMyEmailSignatureInput {
  text: String!
  markdown: String
}

type UpsertMyEmailSignatureOutput {
  emailSignature: EmailSignature
  result: UpsertResult
  error: MutationError
}

enum DoneStatusDetail {
  IGNORED
  DONE_MANUALLY_SET
  DONE_AUTOMATICALLY_SET
  TIMER_EXPIRED @deprecated(reason: "Use DONE_AUTOMATICALLY_SET instead.")
}

input MarkThreadAsDoneInput {
  threadId: ID!
  statusDetail: DoneStatusDetail
}

type MarkThreadAsDoneOutput {
  thread: Thread
  error: MutationError
}

enum StatusDetailType {
  CREATED
  IN_PROGRESS
  NEW_REPLY
  THREAD_LINK_UPDATED
  THREAD_DISCUSSION_RESOLVED
  WAITING_FOR_CUSTOMER
  WAITING_FOR_DURATION
  IGNORED
  DONE_MANUALLY_SET
  DONE_AUTOMATICALLY_SET
  TIMER_EXPIRED @deprecated(reason: "Use DONE_AUTOMATICALLY_SET instead.")
}

enum TodoStatusDetail {
  CREATED
  IN_PROGRESS
  NEW_REPLY
  THREAD_LINK_UPDATED
  THREAD_DISCUSSION_RESOLVED
}

input MarkThreadAsTodoInput {
  threadId: ID!
  statusDetail: TodoStatusDetail
}

type MarkThreadAsTodoOutput {
  thread: Thread
  error: MutationError
}

input ChangeThreadPriorityInput {
  threadId: ID!
  priority: Int!
}

type ChangeThreadPriorityOutput {
  thread: Thread
  error: MutationError
}

input UpdateThreadTitleInput {
  threadId: ID!
  title: String!
}

type UpdateThreadTitleOutput {
  thread: Thread
  error: MutationError
}

enum SnoozeStatusDetail {
  WAITING_FOR_CUSTOMER
  WAITING_FOR_DURATION
}

input SnoozeThreadInput {
  threadId: ID!
  durationSeconds: Int
  statusDetail: SnoozeStatusDetail
}

type SnoozeThreadOutput {
  thread: Thread
  error: MutationError
}

input AssignThreadInput {
  threadId: ID!
  userId: ID
  machineUserId: ID
}

type AssignThreadOutput {
  thread: Thread
  error: MutationError
}

input UnassignThreadInput {
  threadId: ID!
}

type UnassignThreadOutput {
  thread: Thread
  error: MutationError
}

input AddAdditionalAssigneesInput {
  threadId: ID!
  userIds: [ID!]
  machineUserIds: [ID!]
}

type AddAdditionalAssigneesOutput {
  thread: Thread
  error: MutationError
}

input RemoveAdditionalAssigneesInput {
  threadId: ID!
  userIds: [ID!]
  machineUserIds: [ID!]
}

type RemoveAdditionalAssigneesOutput {
  thread: Thread
  error: MutationError
}

enum ThreadStatus {
  TODO
  SNOOZED
  DONE
}

type ThreadStatusDetailCreated {
  statusChangedAt: DateTime!
  createdAt: DateTime!
}

type ThreadStatusDetailNewReply {
  statusChangedAt: DateTime!
  newReplyAt: DateTime @deprecated(reason: "newReplyAt is no longer supported, query Thread.lastInboundMessageInfo.timestamp instead.")
}

type ThreadStatusDetailReplied {
  repliedAt: DateTime! @deprecated(reason: "ThreadStatusDetailReplied is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailReplied is no longer supported.")
}

type ThreadStatusDetailThreadLinkUpdated {
  statusChangedAt: DateTime!
  updatedAt: DateTime! @deprecated(reason: "Use statusChangedAt instead")
  linearIssueId: ID
}

type ThreadStatusDetailLinearUpdated {
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
  updatedAt: DateTime! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
  linearIssueId: ID! @deprecated(reason: "ThreadStatusDetailLinearUpdated is no longer supported, query ThreadStatusDetailThreadLinkUpdated instead.")
}

type ThreadStatusDetailInProgress {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailThreadDiscussionResolved {
  statusChangedAt: DateTime!
  threadDiscussionId: ID
}

type ThreadStatusDetailUnsnoozed {
  snoozedAt: DateTime! @deprecated(reason: "ThreadStatusDetailUnsnoozed is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailUnsnoozed is no longer supported.")
}

type ThreadStatusDetailSnoozed {
  snoozedAt: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
  snoozedUntil: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
  statusChangedAt: DateTime! @deprecated(reason: "ThreadStatusDetailSnoozed is no longer supported.")
}

type ThreadStatusDetailWaitingForDuration {
  statusChangedAt: DateTime!
  waitingUntil: DateTime!
}

type ThreadStatusDetailWaitingForCustomer {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailIgnored {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailDoneManuallySet {
  statusChangedAt: DateTime!
}

type ThreadStatusDetailDoneAutomaticallySet {
  statusChangedAt: DateTime!
  afterSeconds: Int
}

union ThreadStatusDetail = ThreadStatusDetailCreated | ThreadStatusDetailSnoozed | ThreadStatusDetailUnsnoozed | ThreadStatusDetailNewReply | ThreadStatusDetailReplied | ThreadStatusDetailLinearUpdated | ThreadStatusDetailInProgress | ThreadStatusDetailWaitingForCustomer | ThreadStatusDetailWaitingForDuration | ThreadStatusDetailThreadLinkUpdated | ThreadStatusDetailIgnored | ThreadStatusDetailDoneManuallySet | ThreadStatusDetailDoneAutomaticallySet | ThreadStatusDetailThreadDiscussionResolved

enum MessageSource {
  CHAT
  EMAIL
  API
  SLACK
  MS_TEAMS
  DISCORD
}

type ThreadMessageInfo {
  """The datetime when the last message was received."""
  timestamp: DateTime!

  """The source through which the message came through."""
  messageSource: MessageSource!
}

union ThreadAssignee = User | MachineUser | System

interface ThreadChannelAssociation {
  id: ID!
  companyId: ID
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type SlackThreadChannelAssociation implements ThreadChannelAssociation {
  id: ID!
  companyId: ID
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  connectedSlackChannelId: ID!
}

input CreateThreadChannelAssociationInput {
  companyIdentifier: CompanyIdentifierInput!
  connectedSlackChannelId: ID
}

type CreateThreadChannelAssociationOutput {
  threadChannelAssociation: ThreadChannelAssociation
  error: MutationError
}

input DeleteThreadChannelAssociationInput {
  threadChannelAssociationId: ID!
}

type DeleteThreadChannelAssociationOutput {
  error: MutationError
}

type SlackThreadChannelDetails {
  slackChannelId: String!
  slackChannelName: String!
  slackTeamId: String!
  slackTeamName: String!
}

type ChatThreadChannelDetails {
  customerReadAt: DateTime!
}

type DiscordThreadChannelDetails {
  discordGuildId: String!
  discordChannelId: String!
  discordChannelName: String
}

type ImportThreadChannelDetails {
  importSourceUrl: String
  importIntegrationKey: String!
}

union ThreadChannelDetails = SlackThreadChannelDetails | ChatThreadChannelDetails | DiscordThreadChannelDetails | ImportThreadChannelDetails

input SlackThreadChannelDetailsInput {
  slackChannelId: ID!
  slackTeamId: ID!
}

input ThreadChannelDetailsInput {
  slack: SlackThreadChannelDetailsInput
}

enum ThreadChannel {
  EMAIL
  SLACK
  CHAT
  API
  MS_TEAMS
  DISCORD
  IMPORT
}

input ThreadTimelineEntriesFilter {
  """Only return message timeline entries."""
  isMessage: Boolean
}

"""
A thread represents a conversation with a customer, around a specific topic.
"""
type Thread {
  """The unique identifier of the thread."""
  id: ID!

  """The human-readable identifier of the thread, ie T-1234."""
  ref: String!

  """The customer involved in this thread."""
  customer: Customer!

  """
  The title of this thread, which allows to quickly identify what it is about.
  """
  title: String!

  """The description of this thread."""
  description: String

  """
  The preview text of the thread reflects the current state of the thread. As such, it might be updated when new activity happens in the thread.
  """
  previewText: String

  """
  The priority of the thread. Valid values are 0, 1, 2, 3, from most to least urgent.
  """
  priority: Int!

  """
  The external ID of this thread. You can use this field to store your own unique identifier for this thread.
  """
  externalId: ID

  """The status of this thread."""
  status: ThreadStatus!

  """The datetime when the status of this thread was last changed."""
  statusChangedAt: DateTime!

  """The actor who last changed the status of this thread."""
  statusChangedBy: Actor!

  """
  Additional details about the current thread status. For instance, how long it will be snoozed for.
  """
  statusDetail: ThreadStatusDetail

  """Who or what this thread is assigned to."""
  assignedTo: ThreadAssignee

  """
  The datetime when this thread was last assigned to someone or something.
  """
  assignedAt: DateTime

  """Additional assignees for this thread."""
  additionalAssignees: [ThreadAssignee!]!

  """The labels attached to this thread."""
  labels: [Label!]!

  """The links attached to this thread."""
  links(first: Int, after: String, last: Int, before: String): ThreadLinkConnection!

  """The thread fields attached to this thread."""
  threadFields: [ThreadField!]!

  """The thread discussions attached to this thread."""
  threadDiscussions: [ThreadDiscussion!]!

  """All of the timeline entries in this thread."""
  timelineEntries(filters: ThreadTimelineEntriesFilter, first: Int, after: String, last: Int, before: String): TimelineEntryConnection!

  """First inbound message on the thread."""
  firstInboundMessageInfo: ThreadMessageInfo

  """First outbound message on the thread."""
  firstOutboundMessageInfo: ThreadMessageInfo

  """Last inbound message received."""
  lastInboundMessageInfo: ThreadMessageInfo

  """Last outbound message received."""
  lastOutboundMessageInfo: ThreadMessageInfo

  """The datetime when this thread was created."""
  createdAt: DateTime!

  """The actor who created this thread."""
  createdBy: Actor!

  """The datetime when this thread was last updated."""
  updatedAt: DateTime!

  """The actor who last updated this thread."""
  updatedBy: Actor!

  """
  The support email addresses involved in this thread.
  A support email address is either the default support email address or an alternate support email address.
  A support email address is considered to be involved in a thread when any participant in the thread uses it as their email recipient.
  """
  supportEmailAddresses: [String!]!

  """The tenant this thread is associated with."""
  tenant: Tenant

  """
  The tier this thread is associated with. Tiers mandate the SLAs for this thread.
  """
  tier: Tier

  """
  If this thread has a linked SLA, this will inform on the status of its objectives.
  """
  serviceLevelAgreementStatusSummary: ServiceLevelAgreementStatusSummary!

  """The channel this thread belongs to."""
  channel: ThreadChannel!

  """Details about the channel this thread is on."""
  channelDetails: ThreadChannelDetails

  """The participants in this thread."""
  participants(first: Int, after: String, last: Int, before: String): ActorConnection!

  """The survey responses for this thread."""
  surveyResponse: SurveyResponse

  """The escalation details for this thread."""
  escalationDetails: ThreadEscalationDetails
}

type ThreadEscalationDetails {
  """The escalation path this thread is associated with."""
  escalationPath: EscalationPath!

  """
  The step this thread will be escalated to. If it is null, the thread is at the end of the escalation path.
  """
  nextEscalationPathStep: EscalationPathStep
}

type SurveyResponse {
  id: ID!
  sentiment: SentimentType
  rating: Int
  surveyId: ID
  comment: String
  respondedAt: DateTime
  createdAt: DateTime!
  createdBy: Actor!
  updatedAt: DateTime!
  updatedBy: Actor!
}

type ActorEdge {
  cursor: String!
  node: Actor!
}

type ActorConnection {
  edges: [ActorEdge!]!
  pageInfo: PageInfo!
}

enum ServiceLevelAgreementStatus {
  PENDING
  IMMINENT_BREACH
  BREACHING
  BREACHED
  ACHIEVED
  CANCELLED
}

type ServiceLevelAgreementStatusDetailPending {
  """The time when this SLA will breach."""
  breachingAt: DateTime!
}

type ServiceLevelAgreementStatusDetailImminentBreach {
  """The time when this SLA will breach."""
  breachingAt: DateTime!
}

type ServiceLevelAgreementStatusDetailBreaching {
  """The time when this SLA breached."""
  breachedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailAchieved {
  """The time when this SLA was achieved."""
  achievedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailBreached {
  """The time when this SLA breached."""
  breachedAt: DateTime!

  """The time when we completed this breached SLA."""
  completedAt: DateTime!
}

type ServiceLevelAgreementStatusDetailCancelled {
  """The time when this SLA was cancelled."""
  cancelledAt: DateTime!
}

union ServiceLevelAgreementStatusDetail = ServiceLevelAgreementStatusDetailPending | ServiceLevelAgreementStatusDetailImminentBreach | ServiceLevelAgreementStatusDetailBreaching | ServiceLevelAgreementStatusDetailAchieved | ServiceLevelAgreementStatusDetailBreached | ServiceLevelAgreementStatusDetailCancelled

type ServiceLevelAgreementStatusSummary {
  firstResponseTime: ServiceLevelAgreementStatusDetail
  nextResponseTime: ServiceLevelAgreementStatusDetail
}

"""Only one of the fields can be set."""
input CustomerIdentifierInput {
  externalId: ID
  emailAddress: String
  customerId: ID
}

"""Only one of the fields can be set."""
input CreateThreadAssignedToInput {
  userId: ID
  machineUserId: ID
}

input CreateThreadInput {
  """
  The identifier of the customer being either the existing customer ID, the customer's email address or and external ID.
  """
  customerIdentifier: CustomerIdentifierInput!

  """The title of the thread."""
  title: String

  """The components used to create the first timeline entry in the thread."""
  components: [ComponentInput!] @deprecated(reason: "Use sendChat and sendCustomerChat mutations instead. Both allow you to backdate messages.")

  """An array of attachments for the first timeline entry in the thread."""
  attachmentIds: [ID!] @deprecated(reason: "Use sendChat and sendCustomerChat mutations instead. Both allow you to backdate messages.")

  """An array of label types to attach to the thread upon creation."""
  labelTypeIds: [ID!]

  """An array of thread fields to attach to the thread upon creation."""
  threadFields: [CreateThreadFieldOnThreadInput!]

  """User or machine user this thread should be assigned to."""
  assignedTo: CreateThreadAssignedToInput

  """
  The external ID of this thread. You can use this field to store your own unique identifier for this thread.
  """
  externalId: ID

  """
  The optional description for this thread. This is used to display a preview of the thread in the UI.
  If not provided, we will automatically infer it from the components you provided.
  """
  description: String

  """
  The priority of the thread. Valid values are 0, 1, 2, 3, from most to least urgent, defaults to 2 (normal).
  """
  priority: Int

  """A thread may be assigned to a specific tenant."""
  tenantIdentifier: TenantIdentifierInput

  """
  The channel to create the thread for. Currently supported: API, EMAIL, SLACK. Defaults to API.
  """
  channel: ThreadChannel

  """Channel details for the thread, required if channel is SLACK."""
  channelDetails: ThreadChannelDetailsInput
}

type CreateThreadOutput {
  thread: Thread
  error: MutationError
}

input MarkCustomerAsSpamInput {
  customerId: ID!
}

input UnmarkCustomerAsSpamInput {
  customerId: ID!
}

type MarkCustomerAsSpamOutput {
  customer: Customer
  error: MutationError
}

type UnmarkCustomerAsSpamOutput {
  customer: Customer
  error: MutationError
}

type SubscriptionEventType {
  eventType: String!
  description: String!
}

type WebhookVersionEdge {
  cursor: String!
  node: WebhookVersion!
}

type WebhookVersionConnection {
  edges: [WebhookVersionEdge!]!
  pageInfo: PageInfo!
}

type WebhookTargetEdge {
  cursor: String!
  node: WebhookTarget!
}

type WebhookTargetConnection {
  edges: [WebhookTargetEdge!]!
  pageInfo: PageInfo!
}

type WebhookVersion {
  version: String!
  isDeprecated: Boolean!
  isLatest: Boolean!
}

type WebhookTarget {
  id: ID!
  url: String!
  description: String!
  eventSubscriptions: [WebhookTargetEventSubscription!]!
  version: String!
  isEnabled: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WebhookTargetEventSubscription {
  eventType: String!
}

input WebhookTargetEventSubscriptionInput {
  eventType: String!
}

input CreateWebhookTargetInput {
  url: String!
  eventSubscriptions: [WebhookTargetEventSubscriptionInput!]!
  isEnabled: Boolean!
  description: String!
  version: String
}

input UpdateWebhookTargetInput {
  webhookTargetId: ID!
  url: StringInput
  eventSubscriptions: [WebhookTargetEventSubscriptionInput!]
  isEnabled: BooleanInput
  description: StringInput
  version: StringInput
}

input DeleteWebhookTargetInput {
  webhookTargetId: ID!
}

type CreateWebhookTargetOutput {
  webhookTarget: WebhookTarget
  error: MutationError
}

type UpdateWebhookTargetOutput {
  webhookTarget: WebhookTarget
  error: MutationError
}

type DeleteWebhookTargetOutput {
  error: MutationError
}

input CustomerCardConfigOrderInput {
  """The ID of the customer card config to be reordered."""
  customerCardConfigId: ID!

  """The order the customer card config should have."""
  order: Int!
}

input ReorderCustomerCardConfigsInput {
  """An array of ordering updates."""
  customerCardConfigOrders: [CustomerCardConfigOrderInput!]!
}

type ReorderCustomerCardConfigsOutput {
  """The reordered customer card configs."""
  customerCardConfigs: [CustomerCardConfig!]
  error: MutationError
}

"""An API header that will be sent to the configured API URL."""
input CustomerCardConfigApiHeaderInput {
  """
  The name of the header, trimmed and treated case insensitively for deduplication purposes (min length: 1, max length: 100). Not all header names are allowed.
  """
  name: String!

  """
  The value of the header, treated case sensitively for deduplication purposes (min length: 1, max length: 500).
  """
  value: String!
}

"""
Input type to create a new customer card config.

By default new customer cards will have an ordering of 100000 (to place them at the bottom).
"""
input CreateCustomerCardConfigInput {
  """The title of the card (max length: 500 characters)."""
  title: String!

  """
  The key of the card (must be unique in a workspace, max length: 500 characters, must match regex: `[a-zA-Z0-9_-]+`).
  """
  key: String!

  """
  The default time the card should be cached for if no TTL is provided in the card response. (minimum: 15 seconds, maximum: 1 year or  31,536,000 seconds).
  """
  defaultTimeToLiveSeconds: Int!

  """
  The URL from which this card should be loaded (must start with `https://` and be a valid URL, max length: 600 characters).
  """
  apiUrl: String!

  """An array of headers name-value pairs (maximum length of array: 20)."""
  apiHeaders: [CustomerCardConfigApiHeaderInput!]!
}

type CreateCustomerCardConfigOutput {
  """The created customer card config."""
  customerCardConfig: CustomerCardConfig
  error: MutationError
}

"""
For constraints and details on the fields see the `CustomerCardConfig` type.
"""
input UpdateCustomerCardConfigInput {
  """The customer card config to update."""
  customerCardConfigId: ID!

  """If provided, will update the order."""
  order: IntInput

  """If provided, will update the title."""
  title: StringInput

  """If provided, will update the key. Keys must be unique in a workspace."""
  key: StringInput

  """If provided, will update the default time to live seconds."""
  defaultTimeToLiveSeconds: IntInput

  """
  If provided, will update the API URL. Requires the `customerCardConfigApiDetails:edit` permission.
  """
  apiUrl: StringInput

  """
  If provided, will replace the existing API headers. Requires the `customerCardConfigApiDetails:edit` permission.
  """
  apiHeaders: [CustomerCardConfigApiHeaderInput!]

  """If provided, will update the enabled flag."""
  isEnabled: BooleanInput
}

type UpdateCustomerCardConfigOutput {
  """The updated customer card config."""
  customerCardConfig: CustomerCardConfig
  error: MutationError
}

input DeleteCustomerCardConfigInput {
  """The customer card config ID to delete."""
  customerCardConfigId: ID!
}

type DeleteCustomerCardConfigOutput {
  error: MutationError
}

input ReloadCustomerCardInstanceInput {
  customerId: ID!
  customerCardConfigId: ID!
  threadId: ID
}

type ReloadCustomerCardInstanceOutput {
  """
  The reloaded customer card instance. Currently this will always be a `CustomerCardInstanceLoading` type.
  """
  customerCardInstance: CustomerCardInstance
  error: MutationError
}

"""An input to specify the scope for a setting."""
input SettingScopeInput {
  """
  An optional ID input. Depends on the type of scope if this is required.
  """
  id: ID

  """Determines the type of the scope."""
  scopeType: SettingScopeType!
}

"""
An input "union" where exactly one field may be be provided as an input.
Current API only supports booleans but as the API expands more optional fields will be added.
"""
input SettingValueInput {
  """If the setting value is a boolean then this field should be set."""
  boolean: Boolean

  """If the setting value is a string then this field should be set."""
  string: String

  """If the setting value is a number then this field should be set"""
  number: Int

  """If the setting value is a string array then this field should be set."""
  stringArray: [String]
}

"""An input provided to the `updateSetting` mutation."""
input UpdateSettingInput {
  """A code for the setting."""
  code: String!

  """A valid scope for the setting code."""
  scope: SettingScopeInput!

  """The setting value."""
  value: SettingValueInput!
}

"""
An output type provided by the `updateSetting` mutation.
Returns the updated setting or an error.
"""
type UpdateSettingOutput {
  """The updated setting."""
  setting: Setting
  error: MutationError
}

input CreateMySlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateMySlackIntegrationOutput {
  integration: UserSlackIntegration
  error: MutationError
}

input CreateUserAuthSlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateUserAuthSlackIntegrationOutput {
  integration: UserAuthSlackIntegration
  error: MutationError
}

input CreateWorkspaceSlackIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceSlackIntegrationOutput {
  integration: WorkspaceSlackIntegration
  error: MutationError
}

input RefreshWorkspaceSlackChannelIntegrationInput {
  integrationId: ID!
  authCode: String!
  redirectUrl: String!
}

type RefreshWorkspaceSlackChannelIntegrationOutput {
  integration: WorkspaceSlackChannelIntegration
  error: MutationError
}

input DeleteWorkspaceSlackIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceSlackIntegrationOutput {
  integration: WorkspaceSlackIntegration
  error: MutationError
}

input CreateWorkspaceSlackChannelIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceSlackChannelIntegrationOutput {
  integration: WorkspaceSlackChannelIntegration
  error: MutationError
}

input DeleteWorkspaceSlackChannelIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceSlackChannelIntegrationOutput {
  integration: WorkspaceSlackChannelIntegration
  error: MutationError
}

type DeleteMySlackIntegrationOutput {
  error: MutationError
}

input DeleteUserAuthSlackIntegrationInput {
  slackTeamId: String!
}

type DeleteUserAuthSlackIntegrationOutput {
  error: MutationError
}

type SlackUserConnection {
  edges: [SlackUserEdge!]!
  pageInfo: PageInfo!
}

type SlackUserEdge {
  cursor: String!
  node: SlackUser!
}

type SlackUser {
  id: ID!
  slackUserId: ID!
  slackAvatarUrl72px: String
  slackHandle: String!
  fullName: String!
  isInChannel: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

input BulkJoinSlackChannelsInput {
  integrationId: ID!
}

type BulkJoinSlackChannelsOutput {
  error: MutationError
}

input UpdateConnectedSlackChannelInput {
  connectedSlackChannelId: ID!
  channelType: ConnectedSlackChannelType
  isEnabled: BooleanInput
}

type UpdateConnectedSlackChannelOutput {
  connectedSlackChannel: ConnectedSlackChannel
  error: MutationError
}

input ConnectedSlackChannelsFilter {
  slackTeamIds: [String!]
  channelTypes: [ConnectedSlackChannelType!]
  isEnabled: BooleanInput
}

type ConnectedSlackChannelConnection {
  pageInfo: PageInfo!
  edges: [ConnectedSlackChannelEdge!]!
  totalCount: Int!
}

type ConnectedSlackChannelEdge {
  cursor: String!
  node: ConnectedSlackChannel!
}

enum ConnectedSlackChannelType {
  """A channel that Plain tracks for customer support requests."""
  CUSTOMER

  """A channel that Plain tracks for internal team discussions."""
  DISCUSSION
}

type ConnectedSlackChannel {
  id: ID!
  slackTeamId: String!
  slackChannelId: String!
  name: String!
  channelType: ConnectedSlackChannelType!
  isEnabled: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  threadChannelAssociations: [SlackThreadChannelAssociation!]!
}

type ConnectedDiscordChannel {
  id: ID!
  discordGuildId: String!
  discordChannelId: String!
  name: String!
  isEnabled: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type ConnectedDiscordChannelConnection {
  pageInfo: PageInfo!
  edges: [ConnectedDiscordChannelEdge!]!
}

type ConnectedDiscordChannelEdge {
  cursor: String!
  node: ConnectedDiscordChannel!
}

input CreateWorkspaceDiscordChannelIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateWorkspaceDiscordChannelIntegrationOutput {
  integration: WorkspaceDiscordChannelIntegration
  error: MutationError
}

input CreateWorkspaceDiscordIntegrationInput {
  name: String!
  webhookUrl: String!
}

type CreateWorkspaceDiscordIntegrationOutput {
  integration: WorkspaceDiscordIntegration
  error: MutationError
}

input DeleteWorkspaceDiscordIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceDiscordIntegrationOutput {
  integration: WorkspaceDiscordIntegration
  error: MutationError
}

input DeleteWorkspaceDiscordChannelIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceDiscordChannelIntegrationOutput {
  error: MutationError
}

input DeleteUserAuthDiscordChannelIntegrationInput {
  integrationId: ID!
}

type DeleteUserAuthDiscordChannelIntegrationOutput {
  error: MutationError
}

input RefreshConnectedDiscordChannelsInput {
  discordGuildId: String!
}

type RefreshConnectedDiscordChannelsOutput {
  error: MutationError
}

input UpdateConnectedDiscordChannelInput {
  connectedDiscordChannelId: ID!
  isEnabled: BooleanInput
}

type UpdateConnectedDiscordChannelOutput {
  connectedDiscordChannel: ConnectedDiscordChannel
  error: MutationError
}

input CreateUserAuthDiscordChannelIntegrationInput {
  discordGuildId: String!
  authCode: String!
  redirectUrl: String!
}

type CreateUserAuthDiscordChannelIntegrationOutput {
  integration: UserAuthDiscordChannelIntegration
  error: MutationError
}

type UserAuthDiscordChannelIntegration {
  id: ID!
  discordGuildId: String!
  discordUserId: String!
  discordUsername: String!
  discordGlobalName: String
  discordUserEmail: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type UserAuthDiscordChannelIntegrationEdge {
  cursor: String!
  node: UserAuthDiscordChannelIntegration!
}

type UserAuthDiscordChannelIntegrationConnection {
  edges: [UserAuthDiscordChannelIntegrationEdge!]!
  pageInfo: PageInfo!
}

input CreateMyLinearIntegrationInput {
  authCode: String!
  redirectUrl: String!
}

type CreateMyLinearIntegrationOutput {
  integration: UserLinearIntegration
  error: MutationError
}

type DeleteMyLinearIntegrationOutput {
  error: MutationError
}

input CreateMyMSTeamsIntegrationInput {
  authCode: ID!
  redirectUrl: String!
}

type CreateMyMSTeamsIntegrationOutput {
  integration: UserMSTeamsIntegration
  error: MutationError
}

type DeleteMyMSTeamsIntegrationOutput {
  integration: UserMSTeamsIntegration
  error: MutationError
}

input CreateWorkspaceMSTeamsIntegrationInput {
  msTeamsTenantId: ID!
}

type CreateWorkspaceMSTeamsIntegrationOutput {
  integration: WorkspaceMSTeamsIntegration
  error: MutationError
}

input DeleteWorkspaceMSTeamsIntegrationInput {
  integrationId: ID!
}

type DeleteWorkspaceMSTeamsIntegrationOutput {
  integration: WorkspaceMSTeamsIntegration
  error: MutationError
}

type WorkspaceMSTeamsIntegration {
  id: ID!
  msTeamsTenantId: ID!
  isReinstallRequired: Boolean!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

enum ChangeType {
  ADDED
  UPDATED
  REMOVED
}

type TimelineEntryChange {
  changeType: ChangeType!
  timelineEntry: TimelineEntry!
}

type CustomerChange {
  changeType: ChangeType!
  customer: Customer!
}

type ThreadChange {
  changeType: ChangeType!
  thread: Thread!
}

type UserChange {
  changeType: ChangeType!
  user: User!
}

type CustomerCardInstanceChange {
  changeType: ChangeType!
  customerCardInstance: CustomerCardInstance!
}

type ThreadFieldSchemaChange {
  changeType: ChangeType!
  threadFieldSchema: ThreadFieldSchema!
}

type SubscriptionAcknowledgement {
  subscriptionId: ID!
}

union CustomerCardInstanceChangesResult = CustomerCardInstanceChange | SubscriptionAcknowledgement

input CustomerChangesFilter {
  assignedToUser: [ID!]
}

type Subscription {
  timelineChanges(customerId: ID!): TimelineEntryChange!
  threadTimelineChanges(threadId: ID!): TimelineEntryChange!
  customerChanges(filters: CustomerChangesFilter @deprecated): CustomerChange!
  threadChanges: ThreadChange!
  customerCardInstanceChanges(customerId: ID!): CustomerCardInstanceChangesResult!
  userChanges: UserChange!
  threadFieldSchemaChanges: ThreadFieldSchemaChange!
}

input UpsertCustomerGroupInput {
  identifier: CustomerGroupIdentifier!
  name: String!
  key: String!
  color: String!
  externalId: String
}

type UpsertCustomerGroupOutput {
  customerGroup: CustomerGroup
  result: UpsertResult
  error: MutationError
}

input CreateCustomerGroupInput {
  name: String!
  key: String!
  color: String!
  externalId: String
}

type CreateCustomerGroupOutput {
  customerGroup: CustomerGroup
  error: MutationError
}

input UpdateCustomerGroupInput {
  customerGroupId: ID!
  name: StringInput
  key: StringInput
  color: StringInput
  externalId: OptionalStringInput
}

type UpdateCustomerGroupOutput {
  customerGroup: CustomerGroup
  error: MutationError
}

input DeleteCustomerGroupInput {
  customerGroupId: ID!
}

type DeleteCustomerGroupOutput {
  error: MutationError
}

input CustomerGroupIdentifier {
  customerGroupId: ID
  customerGroupKey: String
  externalId: String
}

input AddCustomerToCustomerGroupsInput {
  customerId: ID!
  customerGroupIdentifiers: [CustomerGroupIdentifier!]!
}

type AddCustomerToCustomerGroupsOutput {
  customerGroupMemberships: [CustomerGroupMembership!]
  error: MutationError
}

input RemoveCustomerFromCustomerGroupsInput {
  customerId: ID!
  customerGroupIdentifiers: [CustomerGroupIdentifier!]!
}

type RemoveCustomerFromCustomerGroupsOutput {
  error: MutationError
}

"""Query to search for companies."""
input CompaniesSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive on these two fields:
  - the company name (partial match)
  - the company domain name (partial match)
  """
  term: String!
}

type CompanySearchResult {
  company: Company!
}

type CompanySearchResultEdge {
  cursor: String!
  node: CompanySearchResult!
}

type CompanySearchResultConnection {
  edges: [CompanySearchResultEdge!]!
  pageInfo: PageInfo!
}

"""Query to search for tenants."""
input TenantsSearchQuery {
  """
  The term to search for. It must be at least 2 characters long. The search is case-insensitive on these two fields:
  - the tenant name (partial match)
  - the tenant external id (exact match)
  """
  term: String!
}

type TenantSearchResult {
  tenant: Tenant!
}

type TenantSearchResultEdge {
  cursor: String!
  node: TenantSearchResult!
}

type TenantSearchResultConnection {
  edges: [TenantSearchResultEdge!]!
  pageInfo: PageInfo!
}

input StartServiceAuthorizationInput {
  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira, shortcut.
  """
  serviceIntegrationKey: String!
}

input ServiceAuthorizationsFilter {
  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira.
  """
  serviceIntegrationKey: String
}

type ServiceAuthorizationConnectionDetails {
  """
  One of: zendesk, salesforce, freshdesk, helpscout-mailbox, hubspot, jira.
  """
  serviceIntegrationKey: String!
  serviceAuthorizationId: ID!
  hmacDigest: String!
}

type StartServiceAuthorizationOutput {
  connectionDetails: ServiceAuthorizationConnectionDetails
  error: MutationError
}

input CompleteJiraAuthorizationInput {
  refreshToken: String!
  siteId: String!
}

input CompleteServiceAuthorizationInput {
  serviceAuthorizationId: ID!

  """JSON-encoded payload of the service configuration."""
  payload: String
  jira: CompleteJiraAuthorizationInput
}

type CompleteServiceAuthorizationOutput {
  serviceAuthorization: ServiceAuthorization
  error: MutationError
}

input DeleteServiceAuthorizationInput {
  serviceAuthorizationId: ID!
}

type DeleteServiceAuthorizationOutput {
  error: MutationError
}

input DeleteMyServiceAuthorizationInput {
  serviceAuthorizationId: ID!
}

type DeleteMyServiceAuthorizationOutput {
  error: MutationError
}

interface ServiceIntegration {
  name: String!
  key: String!
}

type JiraSite {
  id: ID!
  name: String!
  url: String!
  avatarUrl: String
}

type JiraSiteIntegration implements ServiceIntegration {
  name: String!
  key: String!
  site: JiraSite!
}

type DefaultServiceIntegration implements ServiceIntegration {
  name: String!
  key: String!
}

"""
The status of the service authorization. The status transitions are as follows:
PENDING_AUTH  COMPLETE_AUTH  CONNECTED  REINSTALL_REQUIRED

There is no
"""
enum ServiceAuthorizationStatus {
  """
  Service authorization was requested, but the user has not yet completed the authorization.
  """
  PENDING_AUTH

  """
  User has completed the service authorization, but the service is not yet ready for use.
  This happens when the service requires additional configuration (e.g. creating webhooks
  in the service).
  This is a transient state that typically lasts for a few seconds. Plain will automatically
  attempt to configure the service, and transition to CONNECTED or REINSTALL_REQUIRED.
  """
  COMPLETED_AUTH

  """Service authorization is connected and ready for use."""
  CONNECTED

  """
  Service authorization was revoked, this typically happen when the Plain integration is removed
  from the service. Plain keeps the service authorization to allow for reconnection without
  losing the service's configuration.
  """
  REINSTALL_REQUIRED
}

type ServiceAuthorization {
  id: ID!
  serviceIntegration: ServiceIntegration!
  status: ServiceAuthorizationStatus!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
  connectedAt: DateTime!
  connectedBy: InternalActor!
}

type ServiceAuthorizationEdge {
  cursor: String!
  node: ServiceAuthorization!
}

type ServiceAuthorizationConnection {
  edges: [ServiceAuthorizationEdge!]!
  pageInfo: PageInfo!
}

input BusinessHoursWeekDayInput {
  """
  The time you open for business on this day as an UTC ISO time. For example: 09:00Z .
  """
  startTime: String!

  """
  The time you close for business on this day as an UTC ISO time. For example: 17:00Z .
  """
  endTime: String!
}

"""
Represents the times in which you are open for business during a week. Only provide the days you are open for business.
"""
input BusinessHoursWeekDaysInput {
  monday: BusinessHoursWeekDayInput
  tuesday: BusinessHoursWeekDayInput
  wednesday: BusinessHoursWeekDayInput
  thursday: BusinessHoursWeekDayInput
  friday: BusinessHoursWeekDayInput
  saturday: BusinessHoursWeekDayInput
  sunday: BusinessHoursWeekDayInput
}

input UpsertBusinessHoursInput {
  weekDays: BusinessHoursWeekDaysInput
}

type UpsertBusinessHoursOutput {
  businessHours: BusinessHours
  result: UpsertResult
  error: MutationError
}

type DeleteBusinessHoursOutput {
  error: MutationError
}

type BusinessHoursWeekDays {
  monday: BusinessHoursWeekDay
  tuesday: BusinessHoursWeekDay
  wednesday: BusinessHoursWeekDay
  thursday: BusinessHoursWeekDay
  friday: BusinessHoursWeekDay
  saturday: BusinessHoursWeekDay
  sunday: BusinessHoursWeekDay
}

"""
Represents the times in which you are open for business during a week. If a day is null, it means that day you are not
open for business.
"""
type BusinessHours {
  weekDays: BusinessHoursWeekDays!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type BusinessHoursWeekDay {
  startTime: Time!
  endTime: Time!
}

enum WeekDay {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

type Timezone {
  name: String!
}

type BusinessHoursSlot {
  timezone: Timezone!
  weekday: WeekDay!
  opensAt: String!
  closesAt: String!
}

input BusinessHoursSlotInput {
  timezone: String!
  weekday: WeekDay!
  opensAt: String!
  closesAt: String!
}

input SyncBusinessHoursSlotsInput {
  slots: [BusinessHoursSlotInput!]!
}

type SyncBusinessHoursSlotsOutput {
  slots: [BusinessHoursSlot!]!
  error: MutationError
}

input UpdateThreadTenantInput {
  threadId: ID!
  tenantIdentifier: TenantIdentifierInput
}

type UpdateThreadTenantOutput {
  thread: Thread
  error: MutationError
}

input UpdateThreadTierInput {
  threadId: ID!
  tierIdentifier: TierIdentifierInput
}

type UpdateThreadTierOutput {
  thread: Thread
  error: MutationError
}

input UpdateThreadEscalationPathInput {
  threadId: ID!
  escalationPathId: ID
}

type UpdateThreadEscalationPathOutput {
  thread: Thread
  error: MutationError
}

input AddCustomerToTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

input RemoveCustomerFromTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

input SetCustomerTenantsInput {
  customerIdentifier: CustomerIdentifierInput!
  tenantIdentifiers: [TenantIdentifierInput!]!
}

type AddCustomerToTenantsOutput {
  customer: Customer
  error: MutationError
}

type RemoveCustomerFromTenantsOutput {
  customer: Customer
  error: MutationError
}

type SetCustomerTenantsOutput {
  customer: Customer
  error: MutationError
}

input CompaniesFilter {
  companyIds: [ID!]

  """
  True to only return companies that have been deleted. False to only return companies that have not been deleted.
  Omit to return all companies.
  """
  isDeleted: Boolean
}

enum BillingSubscriptionStatus {
  ACTIVE
  INACTIVE
}

enum BillingPlanKey {
  LEGACY
  EVALUATE
  LAUNCH
  GROW
  SCALE
}

enum BillingSeatType {
  VIEWER @deprecated
  MEMBER @deprecated
  ENG_ROTA @deprecated
}

enum BillingInterval {
  MONTH @deprecated(reason: "Use BillingIntervalUnit.MONTH instead")
  YEAR @deprecated(reason: "Use BillingIntervalUnit.YEAR instead")
}

enum BillingIntervalUnit {
  MONTH
  YEAR
}

input CreateCheckoutSessionInput {
  plan: BillingPlanKey!
  interval: BillingInterval @deprecated(reason: "Use intervalUnit instead")
  intervalUnit: BillingIntervalUnit
}

type CreateCheckoutSessionOutput {
  sessionClientSecret: String
  error: MutationError
}

enum CurrencyCode {
  USD
}

type Price {
  amount: Int!
  currency: CurrencyCode!
}

type PriceTier {
  maxSeats: Int!
  perSeatAmount: Int!
  flatAmount: Int!
}

interface RecurringPrice {
  billingIntervalUnit: BillingIntervalUnit!
  billingIntervalCount: Int!
  currency: CurrencyCode!
}

type PerSeatRecurringPrice implements RecurringPrice {
  billingIntervalUnit: BillingIntervalUnit!
  billingIntervalCount: Int!
  currency: CurrencyCode!
  perSeatAmount: Int!
}

type TieredRecurringPrice implements RecurringPrice {
  billingIntervalUnit: BillingIntervalUnit!
  billingIntervalCount: Int!
  currency: CurrencyCode!
  tiers: [PriceTier!]!
}

type BillingPlan {
  key: BillingPlanKey!
  name: String!
  description: String!
  features: [String!]!
  highlightedLabel: String
  isSelfCheckoutEligible: Boolean!
  monthlyPrice: Price @deprecated(reason: "Use prices instead")
  yearlyPrice: Price @deprecated(reason: "Use prices instead")
  prices: [RecurringPrice!]!
}

type BillingPlanConnection {
  edges: [BillingPlanEdge!]!
  pageInfo: PageInfo!
}

type BillingPlanEdge {
  cursor: String!
  node: BillingPlan!
}

type CreateBillingPortalSessionOutput {
  billingPortalSessionUrl: String
  error: MutationError
}

enum FeatureKey {
  BUSINESS_HOURS
  SLACK_DISCUSSIONS
  SERVICE_LEVEL_AGREEMENTS
  DATA_IMPORTERS
  MS_TEAMS_INTEGRATION
  LIVE_CHAT
  ESCALATION_PATHS
  DISCORD_INTEGRATION
  WORKFLOW_RULES
  CONNECTED_CUSTOMER_SLACK_CHANNELS
  CONNECTED_SUPPORT_EMAIL_ADDRESSES
  INSIGHTS_LOOKBACK_DAYS
  BILLING_ROTA_SEATS
  MORE_ACTIVE_ENG_ROTA_SEATS
  AI_SUGGESTED_RESPONSES
  TEAM_REPORTING
  CUSTOMER_SURVEYS
  HELP_CENTER
}

interface BillingFeatureEntitlement {
  feature: FeatureKey!
  isEntitled: Boolean!
}

type ToggleFeatureEntitlement implements BillingFeatureEntitlement {
  feature: FeatureKey!
  isEntitled: Boolean!
}

type MeteredFeatureEntitlement implements BillingFeatureEntitlement {
  feature: FeatureKey!
  isEntitled: Boolean!
  current: Int!
  limit: Int!
}

type BillingSubscription {
  status: BillingSubscriptionStatus!
  planKey: BillingPlanKey!
  planName: String!
  interval: BillingInterval! @deprecated
  cancelsAt: DateTime
  trialEndsAt: DateTime
  entitlements: [BillingFeatureEntitlement!]!
  endedAt: DateTime
}

input CalculateRoleChangeCostInput {
  roleKey: RoleKey!
  quantity: IntInput
  userId: ID
  usingBillingRotaSeat: BooleanInput
}

type RoleChangeCost {
  """Deprecated. Use fullPrice instead."""
  totalPrice: Price!

  """
  The total price delta for the entire subscription billing period (i.e. non-prorated).
  Could be negative (e.g. swapping member for viewer).
  """
  fullPrice: Price!

  """
  The total price delta for the remainder of the current billing period (i.e. prorated).
  Could be negative (e.g. swapping member for viewer).
  """
  adjustedPrice: Price!

  """
  Total amount that will be invoiced immediately for the role change.
  If this is negative, we would credit the amount to your account.
  """
  dueNowPrice: Price!

  """The number of seats."""
  quantity: Int!
  intervalUnit: BillingIntervalUnit!
  intervalCount: Int!
  addingSeatType: BillingSeatType!
  removingSeatType: BillingSeatType
}

type CalculateRoleChangeCostOutput {
  roleChangeCost: RoleChangeCost
  error: MutationError
}

input AddUserToActiveBillingRotaInput {
  userId: ID!
}

type AddUserToActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

input RemoveUserFromActiveBillingRotaInput {
  userId: ID!
}

type RemoveUserFromActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

type BillingRota {
  onRotaUserIds: [ID!]!
  offRotaUserIds: [ID!]!
}

input UpdateActiveBillingRotaInput {
  userIdsToAdd: [ID!]
  userIdsToRemove: [ID!]
}

type UpdateActiveBillingRotaOutput {
  billingRota: BillingRota
  error: MutationError
}

enum RoleKey {
  OWNER
  ADMIN
  SUPPORT
  VIEWER
  NONE
}

input MachineUsersFilter {
  type: MachineUserType
}

enum MachineUserType {
  """A machine user that interacts via API"""
  API_USER

  """A machine user that represents an AI Agent"""
  AI_AGENT
}

input ChangeBillingPlanInput {
  planKey: BillingPlanKey!
  intervalUnit: BillingIntervalUnit
}

type ChangeBillingPlanOutput {
  error: MutationError
}

input PreviewBillingPlanChangeInput {
  planKey: BillingPlanKey!
  intervalUnit: BillingIntervalUnit
}

type PreviewBillingPlanChangeOutput {
  preview: BillingPlanChangePreview
  error: MutationError
}

type BillingPlanChangePreview {
  immediateCost: Price!
  earliestEffectiveAt: DateTime!
}

type PaymentMethod {
  isAvailable: Boolean!
}

type WorkspaceHmac {
  hmacSecret: String
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type RegenerateWorkspaceHmacOutput {
  workspaceHmac: WorkspaceHmac
  error: MutationError
}

enum WorkspaceFileVisibility {
  PRIVATE
  PUBLIC
}

type WorkspaceFileDownloadUrl {
  downloadUrl: String!

  """
  The time when the download URL will expire. Only set when visibility of the workspace file is PRIVATE.
  """
  expiresAt: DateTime
}

type WorkspaceFile {
  id: ID!
  fileName: String!
  fileSize: FileSize!
  fileExtension: String
  fileMimeType: String!
  visibility: WorkspaceFileVisibility!

  """This URL will only be available after the file has been uploaded."""
  downloadUrl: WorkspaceFileDownloadUrl
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

type WorkspaceFileUploadUrl {
  workspaceFile: WorkspaceFile!
  uploadFormUrl: String!
  uploadFormData: [UploadFormData!]!
  expiresAt: DateTime!
}

input CreateWorkspaceFileUploadUrlInput {
  fileName: String!
  fileSizeBytes: Int!
  visibility: WorkspaceFileVisibility!
}

type CreateWorkspaceFileUploadUrlOutput {
  workspaceFileUploadUrl: WorkspaceFileUploadUrl
  error: MutationError
}

input DeleteWorkspaceFileInput {
  workspaceFileId: ID!
}

type DeleteWorkspaceFileOutput {
  error: MutationError
}

input ResolveCustomerForSlackChannelInput {
  slackTeamId: String!
  slackChannelId: String!
}

type ResolveCustomerForSlackChannelOutput {
  error: MutationError
  customer: Customer
}

type HelpCenterConnection {
  edges: [HelpCenterEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterEdge {
  cursor: String!
  node: HelpCenter!
}

type HelpCenterArticleGroupConnection {
  edges: [HelpCenterArticleGroupEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterArticleGroupEdge {
  cursor: String!
  node: HelpCenterArticleGroup!
}

enum HelpCenterArticleStatus {
  PUBLISHED
  DRAFT
}

type HelpCenterDomainNameVerificationTxtRecord {
  name: String!
  value: String!
}

type HelpCenterDomainSettings {
  domainName: String!
  customDomainName: String
  customDomainNameVerificationTxtRecord: HelpCenterDomainNameVerificationTxtRecord
  customDomainNameVerifiedAt: DateTime
}

type HelpCenterAccessSettings {
  tierIds: [String!]!
  tenantIds: [String!]!
  companyIds: [String!]!
  customerIds: [String!]!
}

enum HelpCenterType {
  PUBLIC
  PRIVATE
  INTERNAL
}

type HelpCenter {
  id: ID!
  type: HelpCenterType!
  publicName: String!
  internalName: String!
  description: String
  domainSettings: HelpCenterDomainSettings!
  portalSettings: HelpCenterPortalSettings!
  headCustomJs: String
  bodyCustomJs: String
  favicon: HelpCenterThemedImage!
  agentAvatarImage: HelpCenterThemedImage!
  logo: HelpCenterThemedImage!
  color: String
  socialPreviewImage: WorkspaceFile
  access: HelpCenterAccessSettings
  publishedAt: DateTime
  publishedBy: InternalActor
  isDeleted: Boolean!
  deletedAt: DateTime
  deletedBy: InternalActor
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!

  """All article groups in the help center."""
  articleGroups(first: Int, after: String, last: Int, before: String): HelpCenterArticleGroupConnection!

  """All articles in the help center."""
  articles(first: Int, after: String, last: Int, before: String): HelpCenterArticleConnection!
}

type HelpCenterIndex {
  helpCenterId: ID!
  hash: String!
  navIndex: [HelpCenterIndexItem!]!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!
}

enum HelpCenterIndexItemType {
  ARTICLE
  ARTICLE_GROUP
}

type HelpCenterIndexItem {
  type: HelpCenterIndexItemType!
  id: ID!
  title: String!
  slug: String!
  parentId: ID
}

type HelpCenterArticleGroup {
  id: ID!
  name: String!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!

  """Parent group in the hierarchy. Null for top-level groups."""
  parentArticleGroup: HelpCenterArticleGroup

  """Direct child groups under this group."""
  childArticleGroups(first: Int, after: String, last: Int, before: String): HelpCenterArticleGroupConnection!

  """Direct articles in this group."""
  articles(first: Int, after: String, last: Int, before: String): HelpCenterArticleConnection!
  slug: String!
}

type HelpCenterArticle {
  id: ID!
  title: String!
  description: String
  contentHtml: String!
  slug: String!
  status: HelpCenterArticleStatus!
  statusChangedAt: DateTime!
  statusChangedBy: InternalActor!
  createdAt: DateTime!
  createdBy: InternalActor!
  updatedAt: DateTime!
  updatedBy: InternalActor!

  """The group this article belongs to, if any."""
  articleGroup: HelpCenterArticleGroup
}

type HelpCenterArticleConnection {
  edges: [HelpCenterArticleEdge!]!
  pageInfo: PageInfo!
}

type HelpCenterArticleEdge {
  cursor: String!
  node: HelpCenterArticle!
}

type HelpCenterThemedImage {
  light: WorkspaceFile
  dark: WorkspaceFile
}

input HelpCenterThemedImageInput {
  light: WorkspaceFileInput!
  dark: WorkspaceFileInput!
}

input CreateHelpCenterInput {
  publicName: String!
  internalName: String!
  type: HelpCenterType!
  description: String!
  headCustomJs: String
  bodyCustomJs: String
  favicon: HelpCenterThemedImageInput
  logo: HelpCenterThemedImageInput
  color: String
  socialPreviewImage: WorkspaceFileInput
  subdomain: String!
}

input HelpCenterPortalSettingsInput {
  isEnabled: Boolean
  threadVisibility: HelpCenterPortalSettingsThreadVisibilityInput
  formFields: [HelpCenterPortalSettingsFormFieldInput!]
}

input HelpCenterAccessSettingsInput {
  tierIds: [String!]
  tenantIds: [String!]
  companyIds: [String!]
  customerIds: [String!]
}

type HelpCenterPortalSettingsThreadVisibility {
  customerCompany: Boolean!
  customerTenants: Boolean!
}

input HelpCenterPortalSettingsThreadVisibilityInput {
  customerCompany: Boolean
  customerTenants: Boolean
}

enum HelpCenterPortalSettingsFormFieldType {
  TEXT_INPUT
  TEXT_AREA
  DROPDOWN
}

input HelpCenterPortalSettingsFormFieldInput {
  id: ID
  type: HelpCenterPortalSettingsFormFieldType!
  label: String!
  placeholder: String
  isRequired: Boolean!
  threadDetails: HelpCenterPortalSettingsThreadDetailsInput
  dropdownOptions: [HelpCenterPortalSettingsDropdownOptionInput!]
}

input ThreadAssigneeInput {
  userId: ID
  machineUserId: ID
}

input HelpCenterPortalSettingsThreadDetailsInput {
  labelTypeIds: [ID!]
  priority: Int
  assignees: [ThreadAssigneeInput!]
  threadFields: [HelpCenterPortalSettingsThreadFieldsInput!]
}

input HelpCenterPortalSettingsThreadFieldsInput {
  threadFieldSchemaId: ID!
  selectedStringValue: String
  selectedBooleanValue: Boolean
}

input HelpCenterPortalSettingsDropdownOptionInput {
  dropdownOptionId: ID
  label: String!
  threadDetails: HelpCenterPortalSettingsThreadDetailsInput
}

type HelpCenterPortalSettingsThreadFields {
  threadFieldSchema: ThreadFieldSchema!
  selectedStringValue: String
  selectedBooleanValue: Boolean
}

type HelpCenterPortalSettingsThreadDetails {
  labelTypes: [LabelType!]
  priority: Int
  assignees: [ThreadAssignee!]
  threadFields: [HelpCenterPortalSettingsThreadFields!]
}

type HelpCenterPortalSettingsTextFormField {
  id: ID!
  type: HelpCenterPortalSettingsFormFieldType!
  label: String!
  placeholder: String
  isRequired: Boolean!
  threadDetails: HelpCenterPortalSettingsThreadDetails
}

type HelpCenterPortalSettingsDropdownOption {
  dropdownOptionId: ID
  label: String!
  threadDetails: HelpCenterPortalSettingsThreadDetails
}

type HelpCenterPortalSettingsDropdownFormField {
  id: ID!
  type: HelpCenterPortalSettingsFormFieldType!
  label: String!
  placeholder: String
  isRequired: Boolean!
  dropdownOptions: [HelpCenterPortalSettingsDropdownOption!]!
}

union HelpCenterPortalSettingsFormField = HelpCenterPortalSettingsTextFormField | HelpCenterPortalSettingsDropdownFormField

type HelpCenterPortalSettings {
  isEnabled: Boolean!
  threadVisibility: HelpCenterPortalSettingsThreadVisibility!
  formFields: [HelpCenterPortalSettingsFormField!]!
}

input UpdateHelpCenterInput {
  helpCenterId: ID!
  type: HelpCenterType
  publicName: String
  internalName: String
  description: String
  headCustomJs: StringInput
  bodyCustomJs: StringInput
  favicon: HelpCenterThemedImageInput
  logo: HelpCenterThemedImageInput
  color: StringInput
  socialPreviewImage: WorkspaceFileInput
  agentAvatarImage: HelpCenterThemedImageInput
  subdomain: String
  portalSettings: HelpCenterPortalSettingsInput
  access: HelpCenterAccessSettingsInput
}

input UpsertHelpCenterArticleInput {
  helpCenterId: ID!
  helpCenterArticleId: ID
  helpCenterArticleGroupId: ID
  title: String!
  description: String
  contentHtml: String!
  slug: String
  status: HelpCenterArticleStatus
}

input CreateHelpCenterArticleGroupInput {
  helpCenterId: ID!
  name: String!
  slug: String

  """Parent group ID. If not provided, creates a top-level group."""
  parentHelpCenterArticleGroupId: ID
}

input UpdateHelpCenterArticleGroupInput {
  helpCenterArticleGroupId: ID!
  name: String
}

type CreateHelpCenterOutput {
  helpCenter: HelpCenter
  error: MutationError
}

type UpdateHelpCenterOutput {
  helpCenter: HelpCenter
  error: MutationError
}

input DeleteHelpCenterInput {
  helpCenterId: ID!
}

type DeleteHelpCenterOutput {
  error: MutationError
}

type UpsertHelpCenterArticleOutput {
  helpCenterArticle: HelpCenterArticle
  error: MutationError
}

input DeleteHelpCenterArticleInput {
  helpCenterArticleId: ID!
}

type DeleteHelpCenterArticleOutput {
  error: MutationError
}

type CreateHelpCenterArticleGroupOutput {
  helpCenterArticleGroup: HelpCenterArticleGroup
  error: MutationError
}

type UpdateHelpCenterArticleGroupOutput {
  helpCenterArticleGroup: HelpCenterArticleGroup
  error: MutationError
}

input DeleteHelpCenterArticleGroupInput {
  helpCenterArticleGroupId: ID!
}

type DeleteHelpCenterArticleGroupOutput {
  error: MutationError
}

input CreateIssueTrackerIssueInput {
  issueTrackerType: String!
  title: String!
  description: String
  fields: [IssueTrackerFieldInput!]!
}

input IssueTrackerFieldInput {
  key: String!
  value: String!
}

type CreateIssueTrackerIssueOutput {
  error: MutationError
  threadLinkCandidate: ThreadLinkCandidate
}

type CustomerSurveyEdge {
  cursor: String!
  node: CustomerSurvey!
}

type CustomerSurveyConnection {
  edges: [CustomerSurveyEdge!]!
  pageInfo: PageInfo!
}